{"version":3,"sources":["proxy-1.js"],"names":[],"mappings":"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","file":"proxy-1-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/******************\n * ES6 Proxy 基本 *\n ******************/\n\n/**\n * Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改\n * 所以属于一种 \"元编程\"（meta programming），即对编程语言进行编程\n *\n * Proxy 可以理解成，在目标对象之前架设一层 \"拦截\"\n * 外界对该对象的访问，都必须先通过这层拦截\n * 因此提供了一种机制，可以对外界的访问进行过滤和改写\n * Proxy 这个词的原意是代理，用在这里表示由它来 \"代理\" 某些操作，可以译为 \"代理器\"\n */\n\n/**\n * ES6 原生提供 Proxy 构造函数：\n * var proxy = new Proxy(target, handler);\n * target 参数表示所要拦截的目标对\n * handler 参数也是一个对象，用来定制拦截行为\n *\n * 注意: 要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作\n * 而不是针对目标对象（上例是空对象）进行操作\n *\n * Proxy 实际上重载（overload）了点运算符\n * 即用自己的定义覆盖了语言的原始定义\n */\n(() => {\n    var proxy = new Proxy({}, {\n        get: function (target, propertyKey, receiver) {\n            console.log(\"[proxy]  [test-\" + 1 + \"]  [proxy#get  propertyKey] = \", propertyKey);\n            return Reflect.get(target, propertyKey, receiver);\n        },\n        set: function (target, propertyKey, value, receiver) {\n            console.log(\"[proxy]  [test-\" + 1 + \"]  [proxy#set  propertyKey] = \", propertyKey);\n            return Reflect.set(target, propertyKey, value, receiver);\n        }\n    })\n    proxy.index = 2;\n    ++proxy.index;\n    console.log('');\n})();\n\n(() => {\n    var proxy = new Proxy({}, {\n        get: function (target, propertyKey, receiver) {\n            return 67;\n        }\n    });\n    console.log(\"[proxy]  [test-\" + 2 + \"]  [proxy.name] = \", proxy.name);\n    console.log(\"[proxy]  [test-\" + 2 + \"]  [proxy.save] = \", proxy.save);\n    console.log(\"[proxy]  [test-\" + 2 + \"]  [proxy.sign] = \", proxy.sign, '\\n');\n})();\n\n/**\n * 如果 handler 没有设置任何拦截，那就等同于直接通向原对象\n */\n(() => {\n    var target = {};\n    var handler = {};\n    // handler 是一个空对象，没有任何拦截效果，访问 handler 就等同于访问 target\n    let proxy = new Proxy(target, handler);\n    proxy.save = 'Save you from anything';\n    console.log(\"[proxy]  [test-\" + 2 + \"]  [target.name] = \", target.save, '\\n');\n})();\n\n\n/**\n * 技巧\n */\n(() => {\n    var proxy = new Proxy({}, {\n        get: function (target, property) {\n            return 'Save you from anything';\n        }\n    });\n\n    let object = Object.create(proxy);\n    console.log(\"[proxy]  [test-\" + 3 + \"]  [object.save] = \", object.save, '\\n');\n})();\n\n/**\n * 设置拦截多个操作\n */\n(() => {\n    let hanlder = {\n        tag: '[handler]  #  ',\n        get: function (target, propertyKey, receiver) {\n            if (propertyKey === 'prototype') {\n                return Object.prototype;\n            }\n            return this.tag + propertyKey;\n        },\n        apply: function (target, thisArgument, argumentsList) {\n            return argumentsList[0];\n        },\n        construct: function (target, argumentsList) {\n            return {value: argumentsList[1]};\n        }\n    };\n\n    let functionProxy = new Proxy(function (x, y) {\n        return x + y;\n    }, hanlder);\n    // handler 代理了 apply 方法\n    console.log(\"[proxy]  [test-\" + 4 + \"]  [functionProxy(22, 33)] = \", functionProxy(22, 33));\n    // handler 代理了 construct 方法\n    console.log(\"[proxy]  [test-\" + 4 + \"]  [new functionProxy(22, 33)] = \", new functionProxy(22, 33));\n    // handler 代理了 get\n    console.log(\"[proxy]  [test-\" + 4 + \"]  [functionProxy.prototype === Object.prototype] = \", functionProxy.prototype === Object.prototype);\n    console.log(\"[proxy]  [test-\" + 4 + \"]  [functionProxy.save] = \", functionProxy.save);\n})();\n\n/**\n （1）get(target, propKey, receiver)\n\n 拦截对象属性的读取，比如 proxy.foo 和 proxy['foo']。\n\n 最后一个参数receiver是一个对象，可选，参见下面 Reflect.get 的部分。\n\n （2）set(target, propKey, value, receiver)\n\n 拦截对象属性的设置，比如 proxy.foo = v 或 proxy['foo'] = v，返回一个布尔值。\n\n （3）has(target, propKey)\n\n 拦截 propKey in proxy 的操作，返回一个布尔值。\n\n （4）deleteProperty(target, propKey)\n\n 拦截 delete proxy[propKey] 的操作，返回一个布尔值。\n\n （5）ownKeys(target)\n\n 拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。\n\n （6）getOwnPropertyDescriptor(target, propKey)\n\n 拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。\n\n （7）defineProperty(target, propKey, propDesc)\n\n 拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\n\n （8）preventExtensions(target)\n\n 拦截 Object.preventExtensions(proxy)，返回一个布尔值。\n\n （9）getPrototypeOf(target)\n\n 拦截 Object.getPrototypeOf(proxy)，返回一个对象。\n\n （10）isExtensible(target)\n\n 拦截 Object.isExtensible(proxy)，返回一个布尔值。\n\n （11）setPrototypeOf(target, proto)\n\n 拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。\n\n 如果目标对象是函数，那么还有两种额外操作可以拦截。\n\n （12）apply(target, object, args)\n\n 拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\n\n （13）construct(target, args)\n\n 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\n */"]}