{"version":3,"sources":["proxy-10.js"],"names":[],"mappings":";;;;;;AAAA;;;;AAIA;;;;AAIA;;;;;;;;AAQA,CAAC,YAAM;AACH,QAAI,SAAS;AACT,qBAAa,uBAAY;AACrB,mBAAO,SAAS,KAAhB;AACH;AAHQ,KAAb;AAKA,QAAI,QAAQ,IAAI,KAAJ,CAAU,MAAV,EAAkB,EAAlB,CAAZ;AACA,YAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,8BAApC,EAAoE,OAAO,WAAP,EAApE;AACA,YAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,6BAApC,EAAmE,MAAM,WAAN,EAAnE,EAAwF,IAAxF;AACH,CATD;;AAWA;;;AAGA,CAAC,YAAM;AACH,QAAI,YAAY,IAAI,OAAJ,EAAhB;;AADG,QAEG,MAFH;AAGC,wBAAY,IAAZ,EAAkB;AAAA;;AACd,sBAAU,GAAV,CAAc,IAAd,EAAoB,IAApB;AACH;;AALF;AAAA;AAAA,gCAOY;AACP,oBAAI,OAAO,UAAU,GAAV,CAAc,IAAd,CAAX;AACA,wBAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,iBAApC,EAAuD,6BAAvD,EAAsF,IAAtF;AACA,uBAAO,IAAP;AACH;AAXF;;AAAA;AAAA;;AAaH,QAAI,MAAM,IAAI,MAAJ,CAAW,KAAX,CAAV;AACA,QAAI,IAAJ;AACA,QAAI,WAAW,IAAI,KAAJ,CAAU,GAAV,EAAe,EAAf,CAAf;AACA;AACA,aAAS,IAAT;;AAEA,YAAQ,GAAR,CAAY,EAAZ;AACH,CApBD;;AAsBA;;;;;;AAMA,CAAC,YAAM;AACH,QAAI,OAAO,IAAI,IAAJ,CAAS,YAAT,CAAX;AACA,QAAI,QAAQ,IAAI,KAAJ,CAAU,IAAV,EAAgB,EAAhB,CAAZ;AACA,QAAI;AACA,cAAM,OAAN;AACH,KAFD,CAEE,OAAO,CAAP,EAAU;AACR,gBAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,WAApC,EAAiD,CAAjD,EAAoD,IAApD;AACH;;AAED,QAAI,iBAAiB;AACjB,WADiB,eACb,MADa,EACL,WADK,EACQ,QADR,EACiB;AAC9B,gBAAI,gBAAgB,SAApB,EAA+B;AAC3B,uBAAO,OAAO,OAAP,CAAe,IAAf,CAAoB,MAApB,CAAP;AACH;AACD,mBAAO,QAAQ,GAAR,CAAY,MAAZ,EAAoB,WAApB,EAAiC,QAAjC,CAAP;AACH;AANgB,KAArB;AAQA,QAAI,aAAa,IAAI,KAAJ,CAAU,IAAV,EAAgB,cAAhB,CAAjB;AACA,YAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,8BAApC,EAAoE,WAAW,OAAX,EAApE,EAA0F,IAA1F;AACH,CAnBD","file":"proxy-10-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/***********************\n * ES6 Proxy this 问题 *\n **********************/\n\n/**\n * Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理\n * 在不做任何拦截的情况下，也无法保证与目标对象的行为一致\n *\n * 主要原因\n *  Proxy 代理的情况下\n *  目标对象内部的 this 关键字会指向 Proxy 代理\n */\n(() => {\n    let target = {\n        compareThis: function () {\n            return this === proxy;\n        }\n    };\n    let proxy = new Proxy(target, {});\n    console.log(\"[proxy]  [test-\" + 1 + \"]  [target.compareThis()] = \", target.compareThis());\n    console.log(\"[proxy]  [test-\" + 1 + \"]  [proxy.compareThis()] = \", proxy.compareThis(), '\\n');\n})();\n\n/**\n * this 指向的变化，导致 Proxy 无法代理目标对象\n */\n(() => {\n    let personMap = new WeakMap();\n    class Person {\n        constructor(name) {\n            personMap.set(this, name);\n        }\n\n        get name() {\n            let name = personMap.get(this);\n            console.log(\"[proxy]  [test-\" + 2 + \"]  [get name]  \", \"   [personMap.get(this)] = \", name);\n            return name;\n        }\n    }\n    let you = new Person('you');\n    you.name;\n    let youProxy = new Proxy(you, {});\n    // youProxy.name 访问时，this 指向 youProxy，导致无法取到值，所以返回 undefined\n    youProxy.name;\n\n    console.log('');\n})();\n\n/**\n * 有些原生对象的内部属性，只有通过正确的 this 才能拿到\n * Proxy 也无法代理这些原生对象的属性\n *\n * 解决办法：this 绑定原对象\n */\n(() => {\n    let date = new Date('2017-02-07');\n    let proxy = new Proxy(date, {});\n    try {\n        proxy.getDate();\n    } catch (e) {\n        console.log(\"[proxy]  [test-\" + 3 + \"]  [e] = \", e, '\\n');\n    }\n\n    let getDateHandler = {\n        get(target, propertyKey, receiver){\n            if (propertyKey === 'getDate') {\n                return target.getDate.bind(target);\n            }\n            return Reflect.get(target, propertyKey, receiver);\n        }\n    }\n    let smartProxy = new Proxy(date, getDateHandler);\n    console.log(\"[proxy]  [test-\" + 3 + \"]  [smartProxy.getDate()] = \", smartProxy.getDate(), '\\n');\n})();\n"]}