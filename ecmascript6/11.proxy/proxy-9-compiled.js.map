{"version":3,"sources":["proxy-9.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;;AAKA,CAAC,YAAM;AACH,QAAI,QAAQ,IAAI,KAAJ,CAAU,EAAV,EAAc;AACtB,yBADsB,6BACJ,MADI,EACG;AACrB,mBAAO,IAAP;AACH;AAHqB,KAAd,CAAZ;AAKA,QAAI;AACA,eAAO,iBAAP,CAAyB,KAAzB;AACH,KAFD,CAEE,OAAO,CAAP,EAAU;AACR,gBAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,oCAApC,EAA0E,OAAO,YAAP,CAAoB,KAApB,CAA1E;AACA,gBAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,WAApC,EAAiD,CAAjD,EAAoD,IAApD;AACH;AACJ,CAZD;;AAcA;;;;AAIA,CAAC,YAAM;AACH,QAAI,QAAQ,IAAI,KAAJ,CAAU,EAAV,EAAc;AACtB,yBADsB,6BACJ,MADI,EACG;AACrB,mBAAO,iBAAP,CAAyB,MAAzB;AACA,mBAAO,IAAP;AACH;AAJqB,KAAd,CAAZ;AAMA,WAAO,iBAAP,CAAyB,KAAzB;AACA,YAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,oCAApC,EAA0E,OAAO,YAAP,CAAoB,KAApB,CAA1E,EAAsG,IAAtG;AACH,CATD;;AAYA;;;;AAIA;;;AAGA,CAAC,YAAM;AACH,QAAI,SAAS,EAAb;;AADG,2BAEmB,MAAM,SAAN,CAAgB,MAAhB,EAAwB,EAAxB,CAFnB;AAAA,QAEE,KAFF,oBAEE,KAFF;AAAA,QAES,MAFT,oBAES,MAFT;;AAGH,UAAM,IAAN,GAAa,OAAb;AACA,YAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,qBAApC,EAA2D,OAAO,IAAlE;AACA,YAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,oBAApC,EAA0D,MAAM,IAAhE;AACA;AACA,QAAI;AACA,cAAM,IAAN;AACH,KAFD,CAEE,OAAO,CAAP,EAAU;AACR,gBAAQ,GAAR,CAAY,oBAAoB,CAApB,GAAwB,WAApC,EAAiD,CAAjD,EAAoD,IAApD;AACH;AACJ,CAZD","file":"proxy-9-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/*******************************************\n * ES6 Proxy 代理 preventExtensions 的场景 *\n ******************************************/\n\n/**\n * preventExtensions 方法拦截 Object.preventExtensions()\n * 该方法必须返回一个布尔值，否则会被自动转为布尔值\n */\n\n/**\n * 有个很大限制：\n * 只有在 目标对象不可扩展时，即：Object.isExtensible(proxy) === false\n * proxy.preventExtensions 才能返回 true，否则会报错\n */\n(() => {\n    let proxy = new Proxy({}, {\n        preventExtensions(target){\n            return true;\n        }\n    });\n    try {\n        Object.preventExtensions(proxy);\n    } catch (e) {\n        console.log(\"[proxy]  [test-\" + 1 + \"]  [Object.isExtensible(proxy)] = \", Object.isExtensible(proxy));\n        console.log(\"[proxy]  [test-\" + 1 + \"]  [e] = \", e, '\\n');\n    }\n})();\n\n/**\n * 为了防止这个问题\n * 需要再 proxy.preventExtensions 方法里面，调用一次 Object.preventExtensions\n */\n(() => {\n    let proxy = new Proxy({}, {\n        preventExtensions(target){\n            Object.preventExtensions(target);\n            return true;\n        }\n    });\n    Object.preventExtensions(proxy);\n    console.log(\"[proxy]  [test-\" + 2 + \"]  [Object.isExtensible(proxy)] = \", Object.isExtensible(proxy), '\\n');\n})();\n\n\n/*******************\n * Proxy.revocable *\n *******************/\n\n/**\n * Proxy.revocable 方法返回一个可取消的 Proxy 实例\n */\n(() => {\n    let target = {};\n    let {proxy, revoke} = Proxy.revocable(target, {});\n    proxy.save = '_save';\n    console.log(\"[proxy]  [test-\" + 3 + \"]  [target.save] = \", target.save);\n    console.log(\"[proxy]  [test-\" + 3 + \"]  [proxy.save] = \", proxy.save);\n    revoke();\n    try {\n        proxy.save;\n    } catch (e) {\n        console.log(\"[proxy]  [test-\" + 3 + \"]  [e] = \", e, '\\n');\n    }\n})();\n\n"]}