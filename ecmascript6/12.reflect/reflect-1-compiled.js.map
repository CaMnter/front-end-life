{"version":3,"sources":["reflect-1.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;;;AAOA;;;;;;;;AAQA;;;;AAIA,CAAC,YAAM;AACH,QAAI,SAAS,EAAC,MAAM,MAAP,EAAb;AACA,YAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,0BAAtC,EAAkE,UAAU,MAA5E;AACA,YAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,qCAAtC,EAA6E,QAAQ,GAAR,CAAY,MAAZ,EAAoB,MAApB,CAA7E,EAA0G,IAA1G;AACH,CAJD;;AAMA;;;;;AAKA,CAAC,YAAM;AACH,QAAI,SAAS,EAAC,MAAM,MAAP,EAAe,OAAO,OAAtB,EAAb;AACA,QAAI,QAAQ,IAAI,KAAJ,CAAU,MAAV,EAAkB;AAC1B,WAD0B,eACtB,MADsB,EACd,WADc,EACD,QADC,EACQ;AAC9B,gBAAI,YAAY,CAAZ,MAAmB,GAAvB,EAA4B;AACxB,sBAAM,MAAM,6BAAN,CAAN;AACH,aAFD,MAEO;AACH,wBAAQ,GAAR,CAAY,MAAZ,EAAoB,WAApB,EAAiC,QAAjC;AACH;AACJ;AAPyB,KAAlB,CAAZ;AASA,QAAI;AACA,cAAM,KAAN;AACH,KAFD,CAEE,OAAO,CAAP,EAAU;AACR,gBAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,WAAtC,EAAmD,CAAnD,EAAsD,IAAtD;AACH;;AAED,QAAI,YAAY,IAAI,KAAJ,CAAU,MAAV,EAAkB;AAC9B,WAD8B,eAC1B,MAD0B,EAClB,IADkB,EACZ;AACd,oBAAQ,GAAR,CAAY,KAAZ,EAAmB,MAAnB,EAA2B,IAA3B;AACA,mBAAO,QAAQ,GAAR,CAAY,MAAZ,EAAoB,IAApB,CAAP;AACH,SAJ6B;AAK9B,sBAL8B,0BAKf,MALe,EAKP,IALO,EAKD;AACzB,oBAAQ,GAAR,CAAY,WAAW,IAAvB;AACA,mBAAO,QAAQ,cAAR,CAAuB,MAAvB,EAA+B,IAA/B,CAAP;AACH,SAR6B;AAS9B,WAT8B,eAS1B,MAT0B,EASlB,IATkB,EASZ;AACd,oBAAQ,GAAR,CAAY,QAAQ,IAApB;AACA,mBAAO,QAAQ,GAAR,CAAY,MAAZ,EAAoB,IAApB,CAAP;AACH;AAZ6B,KAAlB,CAAhB;AAcH,CA/BD;;AAiCA;;;AAGA,CAAC,YAAM;AACH;AACA,YAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,sEAAtC,EAA8G,SAAS,SAAT,CAAmB,KAAnB,CAAyB,IAAzB,CAA8B,KAAK,KAAnC,EAA0C,SAA1C,EAAqD,CAAC,IAAD,CAArD,CAA9G;AACA;AACA,YAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,sDAAtC,EAA8F,QAAQ,KAAR,CAAc,KAAK,KAAnB,EAA0B,SAA1B,EAAqC,CAAC,IAAD,CAArC,CAA9F;AACH,CALD","file":"reflect-1-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/********************\n * ES6 Reflect 基本 *\n ********************/\n\n/**\n * 优点一：\n * 某些方法同时在 Object 和 Reflect 对象上部署\n * 未来的新方法将只部署在 Reflect 对象上\n * 也就是说，从 Reflect 对象上可以拿到语言内部的方法\n */\n\n/**\n * 优点二：\n * 修改某些 Object 方法的返回结果，让其变得更合理\n *\n * Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误\n * 而 Reflect.defineProperty(obj, name, desc) 则会返回 false。\n */\n\n/**\n * 优点三：\n * 命令式 变为 函数式\n */\n(() => {\n    let target = {save: 'save'};\n    console.log(\"[reflect]  [test-\" + 1 + \"]  ['save' in target] = \", 'save' in target);\n    console.log(\"[reflect]  [test-\" + 1 + \"]  [Reflect.has(target, 'save')] = \", Reflect.has(target, 'save'), '\\n');\n})();\n\n/**\n * 优点四：\n * Proxy 的时候，用 Reflect 完成默认行为\n * 不管 Proxy 怎么修改默认行为，总可以在 Reflect 上获取默认行为\n */\n(() => {\n    let target = {save: 'save', _save: '_save'};\n    let proxy = new Proxy(target, {\n        get(target, propertyKey, receiver){\n            if (propertyKey[0] === '_') {\n                throw Error('Can\\'t get hidden attribute');\n            } else {\n                Reflect.get(target, propertyKey, receiver);\n            }\n        }\n    });\n    try {\n        proxy._save;\n    } catch (e) {\n        console.log(\"[reflect]  [test-\" + 2 + \"]  [e] = \", e, '\\n');\n    }\n\n    let loggedObj = new Proxy(target, {\n        get(target, name) {\n            console.log('get', target, name);\n            return Reflect.get(target, name);\n        },\n        deleteProperty(target, name) {\n            console.log('delete' + name);\n            return Reflect.deleteProperty(target, name);\n        },\n        has(target, name) {\n            console.log('has' + name);\n            return Reflect.has(target, name);\n        }\n    });\n})();\n\n/**\n * 很多操作 更易读\n */\n(() => {\n    // old\n    console.log(\"[reflect]  [test-\" + 2 + \"]  [Function.prototype.apply.call(Math.floor, undefined, [1.75])] = \", Function.prototype.apply.call(Math.floor, undefined, [1.75]));\n    // new\n    console.log(\"[reflect]  [test-\" + 2 + \"]  [Reflect.apply(Math.floor, undefined, [1.75])] = \", Reflect.apply(Math.floor, undefined, [1.75]));\n})();"]}