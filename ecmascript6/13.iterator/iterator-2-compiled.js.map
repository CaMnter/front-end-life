{"version":3,"sources":["iterator-2.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;AAIA;;;;AAIA;;;;;;;;;;;AAYA;;;;AAIA,CAAC,YAAM;AACH,QAAI,6BACC,OAAO,QADR,EACmB,YAAY;AAC3B,eAAO;AACH,kBAAM,gBAAY;AACd,uBAAO;AACH,2BAAO,IADJ;AAEH,0BAAM;AAFH,iBAAP;AAIH;AANE,SAAP;AAQH,KAVD,CAAJ;AAYH,CAbD;;AAeA;;;AAGA,CAAC,YAAM;AACH,QAAI,QAAQ,CAAC,MAAD,EAAS,KAAT,EAAgB,MAAhB,EAAwB,UAAxB,CAAZ;AACA,QAAI,WAAW,MAAM,OAAO,QAAb,GAAf;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACnC,gBAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yBAAvC,EAAkE,SAAS,IAAT,EAAlE;AACH;AACD,YAAQ,GAAR,CAAY,EAAZ;AACH,CAPD;;AAUA;;;;;;AAMA;;;;AAIA,CAAC,YAAM;AAAA,QACG,cADH;AAEC,gCAAY,KAAZ,EAAmB,IAAnB,EAAyB;AAAA;;AACrB,iBAAK,KAAL,GAAa,KAAb;AACA,iBAAK,IAAL,GAAY,IAAZ;AACH;;AALF;AAAA,iBAOE,OAAO,QAPT;AAAA,oCAOqB;AAChB,uBAAO,IAAP;AACH;;AAED;;AAXD;AAAA;AAAA,mCAYQ;AACH,oBAAI,QAAQ,KAAK,KAAjB;AACA,oBAAI,QAAQ,KAAK,IAAjB,EAAuB;AACnB,yBAAK,KAAL;AACA,2BAAO,EAAC,OAAO,KAAR,EAAe,MAAM,KAArB,EAAP;AACH,iBAHD,MAGO;AACH,2BAAO,EAAC,OAAO,SAAR,EAAmB,MAAM,IAAzB,EAAP;AACH;AACJ;AApBF;;AAAA;AAAA;;AAuBH,aAAS,iBAAT,CAA2B,KAA3B,EAAkC,IAAlC,EAAwC;AACpC,eAAO,IAAI,cAAJ,CAAmB,KAAnB,EAA0B,IAA1B,CAAP;AACH;;AAzBE;AAAA;AAAA;;AAAA;AA2BH,6BAAiB,kBAAkB,CAAlB,EAAqB,CAArB,CAAjB,8HAA0C;AAAA,gBAAjC,IAAiC;;AACtC,oBAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,cAAvC,EAAuD,IAAvD;AACH;AA7BE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AA+BH,8BAAkB,kBAAkB,CAAlB,EAAqB,CAArB,CAAlB,mIAA2C;AAAA,gBAAlC,KAAkC;;AACvC,oBAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,eAAvC,EAAwD,KAAxD;AACH;AAjCE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkCN,CAlCD","file":"iterator-2-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/*******************************\n * 数据结构的默认 Iterator 接口 *\n *******************************/\n\n/**\n * ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性\n * 一个数据结构只要具有 Symbol.iterator 属性，就可以认为是 \"可遍历的\"\n *\n * Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数\n * 执行这个函数，就会返回一个遍历器\n *\n * 属性名 Symbol.iterator，它是一个表达式，返回 Symbol 对象的 iterator 属性\n * 这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内\n */\n\n\n/**\n * 具有 Symbol.iterator 属性\n * 执行这个属性，会返回一个遍历器对象\n */\n(() => {\n    let target = {\n        [Symbol.iterator]: function () {\n            return {\n                next: function () {\n                    return {\n                        value: 2233,\n                        done: true\n                    };\n                }\n            };\n        }\n    };\n})();\n\n/**\n * 原生具备 Iterator 接口\n */\n(() => {\n    let array = ['save', 'you', 'from', 'anything'];\n    let iterator = array[Symbol.iterator]();\n    for (let i = 0; i < array.length; i++) {\n        console.log(\"[iterator]  [test-\" + 1 + \"]  [iterator.next()] = \", iterator.next());\n    }\n    console.log('');\n})();\n\n\n/**\n * 除开 数组、Set 和 Map 以外\n * 其他数据结构（主要是对象）的 Iterator 接口，都需要自己在 Symbol.iterator 属性上面部署\n * 这样才会被 for...of 循环遍历\n */\n\n/**\n * 实例：\n * 让对象用上 for...of\n */\n(() => {\n    class RangeInterator {\n        constructor(start, stop) {\n            this.value = start;\n            this.stop = stop;\n        }\n\n        [Symbol.iterator]() {\n            return this;\n        }\n\n        // 返回对象的格式 {value: ???, done: ???}\n        next() {\n            let value = this.value;\n            if (value < this.stop) {\n                this.value++;\n                return {value: value, done: false};\n            } else {\n                return {value: undefined, done: true};\n            }\n        }\n    }\n\n    function getRangeInterator(start, stop) {\n        return new RangeInterator(start, stop);\n    }\n\n    for (let save of getRangeInterator(1, 7)) {\n        console.log(\"[iterator]  [test-\" + 2 + \"]  [save] = \", save);\n    }\n\n    for (let value of getRangeInterator(1, 7)) {\n        console.log(\"[iterator]  [test-\" + 2 + \"]  [value] = \", value);\n    }\n})();"]}