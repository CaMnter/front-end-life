{"version":3,"sources":["promise-6.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;AAIA;;;;;AAKA,CAAC,YAAM;AACH,QAAM,OAAO,MAAb;;AAEA,YACK,OADL,CACa,IADb,EAEK,IAFL,CAEU,iBAAS;AACX,gBAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,gCAAtC,EAAwE,KAAxE,EAA+E,IAA/E;AACH,KAJL;;AAMA;;AAEA,QAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AAC7B;AACH,KAFD,EAEG,IAFH,CAEQ,iBAAS,CAEhB,CAJD;AAKH,CAhBD;;AAkBA;;;;;;;AAOA,CAAC,YAAM;AACH,QAAM,OAAO,MAAb;AACA,QAAI,WAAW;AACX,YADW,gBACN,OADM,EACG,MADH,EACW;AAClB,oBAAQ,IAAR;AACH;AAHU,KAAf;AAKA,YACK,OADL,CACa,QADb,EAEK,IAFL,CAEU,iBAAS;AACX,gBAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,gCAAtC,EAAwE,KAAxE,EAA+E,IAA/E;AACH,KAJL;AAKH,CAZD;;AAcA;;;;;AAKA,CAAC,YAAM;AACH,YACK,OADL,CACa,MADb,EAEK,IAFL,CAEU,iBAAS;AACX,gBAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,gCAAtC,EAAwE,KAAxE,EAA+E,IAA/E;AACH,KAJL;AAKH,CAND;;AAQA;;;;;AAKA,CAAC,YAAM;AACH;AACA,eAAW,YAAY;AACnB,gBAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,mCAAtC,EAA2E,IAA3E;AACH,KAFD,EAEG,CAFH;;AAIA;AACA,YACK,OADL,GAEK,IAFL,CAEU,YAAM;AACR,gBAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,4BAAtC,EAAoE,IAApE;AACH,KAJL,EAIO,KAJP,CAIa,iBAAS,CAErB,CAND;AAOA;AACA,YAAQ,GAAR,CAAY,sBAAsB,CAAtB,GAA0B,wBAAtC,EAAgE,IAAhE;AACH,CAhBD","file":"promise-6-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/*********************\n * Promise.resolve() *\n *********************/\n\n/**\n * Promise.resolve 可以 将现有的对象，转换为 Promise 对象\n */\n\n/**\n * Promise.resolve 也是一个简版的 Promise\n *\n * Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例\n */\n(() => {\n    const SAVE = 'save';\n\n    Promise\n        .resolve(SAVE)\n        .then(value => {\n            console.log(\"[promise]  [test-\" + 1 + \"]  [promise # then # value] = \", value, '\\n');\n        });\n\n    // 等价于\n\n    new Promise((resolve, reject) => {\n        resolve();\n    }).then(value => {\n\n    });\n})();\n\n/**\n * Promise.resolve 的参数是一个 thenable 对象\n * thenable 对象指的是具有 then 方法的对象\n *\n * Promise.resolve 方法会将 thenable 对象转为 Promise 对象\n * 然后就立即执行 thenable 对象的 then 方法\n */\n(() => {\n    const SAVE = 'save';\n    let thenable = {\n        then(resolve, reject) {\n            resolve(SAVE);\n        }\n    };\n    Promise\n        .resolve(thenable)\n        .then(value => {\n            console.log(\"[promise]  [test-\" + 2 + \"]  [promise # then # value] = \", value, '\\n');\n        });\n})();\n\n/**\n * 参数不是具有 then 方法的对象\n *\n * Promise.resolve 方法会返回一个新的 Promise 对象，状态设置为 resolved\n */\n(() => {\n    Promise\n        .resolve('save')\n        .then(value => {\n            console.log(\"[promise]  [test-\" + 3 + \"]  [promise # then # value] = \", value, '\\n');\n        })\n})();\n\n/**\n * resolve 的 Promise 对象\n * 是在本轮 \"事件循环\"（event loop）的结束时\n * 而不是在下一轮 \"事件循环\" 的开始时\n */\n(() => {\n    // setTimeout(fn, 0) 在 下一轮 \"事件循环\" 开始时执行\n    setTimeout(function () {\n        console.log(\"[promise]  [test-\" + 4 + \"]  [promise # setTimeout] = three\", '\\n');\n    }, 0);\n\n    // Promise.resolve() 在本轮 \"事件循环\" 结束时执行\n    Promise\n        .resolve()\n        .then(() => {\n            console.log(\"[promise]  [test-\" + 4 + \"]  [promise # then ] = two\", '\\n');\n        }).catch(error => {\n\n    });\n    // console 立即执行，最先输出\n    console.log(\"[promise]  [test-\" + 4 + \"]  [console.log] = one\", '\\n');\n})();\n"]}