{"version":3,"sources":["generator-1.js"],"names":[],"mappings":"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","file":"generator-1-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/**********************\n * Generator 函数基本 *\n *********************/\n\n/**\n * Generator 函数是 ES6 提供的一种异步编程解决方案\n *\n * Generator 函数是一个状态机，封装了多个内部状态\n * 执行 Generator 函数会返回一个遍历器对象，Generator 函数除了状态机，还是一个遍历器对象生成函数\n * 返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态\n */\n\n/**\n * Generator 函数是一个普通函数，但是有两个 特征：\n * function 关键字 与 函数名 之间有 * 号\n * yield 语句，定义不同的内部状态\n */\n\n(() => {\n    function* saveGenerator() {\n        yield 'save';\n        yield 'you';\n        yield 'from';\n        return 'anything'\n    };\n\n    // 调用方法生成 Iterator 对象\n    var save = saveGenerator();\n    console.log(\"[generator]  [test-\" + 1 + \"]  [save.next()] = \", save.next());\n    console.log(\"[generator]  [test-\" + 1 + \"]  [save.next()] = \", save.next());\n    console.log(\"[generator]  [test-\" + 1 + \"]  [save.next()] = \", save.next());\n    console.log(\"[generator]  [test-\" + 1 + \"]  [save.next()] = \", save.next(), '\\n');\n\n    /*\n     * 是 Iterator 就能用 for...of\n     * return 不返回值\n     */\n    save = saveGenerator();\n    for (let value of save) {\n        console.log(\"[generator]  [test-\" + 2 + \"]  [value] = \", value);\n    }\n    console.log('');\n})();\n\n/**\n * Generator 的 星号 可以随便写在 function 和 方法名之间\n */\n(() => {\n    function* A() {\n    }\n\n    function * B() {\n    }\n\n    function *C() {\n    }\n\n    function*D() {\n\n    }\n})();\n\n\n/*********\n * yield *\n *********/\n\n/**\n * Generator 返回的 Iterator 之所有调用 next 方法才会进入到下一个内部状态\n * 是因为： 提供了一种可以暂停执行的函数，yield 语句就是暂停标记\n *\n * 注意：是调用 next 才执行 yield 后面的语句，而不是 next 执行 yield ???\n * yield 也可以实现 \"惰性求值\"（ Lazy Evaluation ）的语法功能\n */\n(() => {\n    function* lazyLoading() {\n        yield 2200 + 33;\n    };\n    console.log(\"[generator]  [test-\" + 3 + \"]  [lazyLoading().next()] = \", lazyLoading().next(), '\\n');\n})();\n\n/**\n * yield 与 return :\n * 遇到 yield，函数暂停执行，下一次再从该位置继续向后执行\n * 而 return 语句不具备位置记忆的功能，只能执行一次 return\n */\n\n/**\n * Generator 可以不用 yield\n */\n(() => {\n    function* generator() {\n        console.log(\"[generator]  [test-\" + 4 + \"]  [function* generator()]\", '\\n');\n    }\n\n    generator().next();\n})();\n\n/**\n * yield 不能再普通方法中定义\n */\n(() => {\n    // function func() {\n    //     yield 2233\n    // }\n})();\n\n/**\n * 实例：深度遍历\n */\n(() => {\n    const NUMBER = 'number';\n    let array = [1, [[2, 3], 4], [5, 6]];\n    let depthTraversal = function *(array) {\n        let length = array.length;\n        for (let i = 0; i < length; i++) {\n            let element = array[i];\n            if (typeof element !== NUMBER) {\n                yield *depthTraversal(element);\n            } else {\n                yield element;\n            }\n        }\n    };\n    console.log(\"[generator]  [test-\" + 5 + \"]  [array] = \", array);\n    for (let value of depthTraversal(array)) {\n        console.log(\"[generator]  [test-\" + 5 + \"]  [value] = \", value);\n    }\n})();"]}