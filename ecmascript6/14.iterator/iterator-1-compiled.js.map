{"version":3,"sources":["iterator-1.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;;;AAOA;;;;;;;;;;;;;AAaA;;;AAGA,CAAC,YAAM;AACH,aAAS,YAAT,CAAsB,KAAtB,EAA6B;AACzB,YAAI,YAAY,CAAhB;AACA,eAAO;AACH,kBAAM,gBAAY;AACd,uBAAO,YAAY,MAAM,MAAlB,GACH,EAAC,OAAO,MAAM,WAAN,CAAR,EADG,GAEH,EAAC,MAAM,IAAP,EAFJ;AAGH;AALE,SAAP;AAOH;AACD,QAAI,QAAQ,CAAC,MAAD,EAAS,KAAT,EAAgB,MAAhB,EAAwB,UAAxB,CAAZ;AACA,QAAI,WAAW,aAAa,KAAb,CAAf;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAAN,GAAe,CAAnC,EAAsC,GAAtC,EAA2C;AACvC,gBAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yBAAvC,EAAkE,SAAS,IAAT,EAAlE;AACH;AACD,YAAQ,GAAR,CAAY,EAAZ;AACH,CAjBD;;AAmBA;;;AAGA,CAAC,YAAM;AACH,aAAS,SAAT,GAAqB;AACjB,YAAI,QAAQ,CAAZ;AACA,eAAO;AACH,kBAAM,gBAAY;AACd,uBAAO,EAAC,OAAO,OAAR,EAAiB,MAAM,KAAvB,EAAP;AACH;AAHE,SAAP;AAKH;;AAED,QAAI,UAAU,WAAd;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,KAAK,CAArB,EAAwB,GAAxB,EAA6B;AACzB,gBAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,wBAAvC,EAAiE,QAAQ,IAAR,EAAjE;AACH;AACD,YAAQ,GAAR,CAAY,EAAZ;AACH,CAfD;;AAiBA","file":"iterator-1-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/************\n * Iterator *\n ************/\n\n/**\n * 作用：\n * 1. 是为各种数据结构，提供一个统一的、简便的访问接口\n * 2. 是使得数据结构的成员能够按某种次序排列\n * 3. 是 ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费\n */\n\n/**\n * 遍历过程：\n *\n * 1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象\n * 2. 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员\n * 3. 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员\n * 4. 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置\n *\n * 每一次调用 next 方法，都会返回数据结构的当前成员的信息。\n * 具体来说，就是返回一个包含 value 和 done 两个属性的对象。\n * 其中，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束\n */\n\n/**\n * 模拟 Iterator\n */\n(() => {\n    function makeIterator(array) {\n        let nextIndex = 0;\n        return {\n            next: function () {\n                return nextIndex < array.length ?\n                    {value: array[nextIndex++]} :\n                    {done: true}\n            }\n        }\n    };\n    let array = ['save', 'you', 'from', 'anything'];\n    let iterator = makeIterator(array);\n    for (let i = 0; i < array.length + 1; i++) {\n        console.log(\"[iterator]  [test-\" + 1 + \"]  [iterator.next()] = \", iterator.next());\n    }\n    console.log('');\n})();\n\n/**\n * 无限 Iterator\n */\n(() => {\n    function idCreater() {\n        let index = 0;\n        return {\n            next: function () {\n                return {value: index++, done: false};\n            }\n        }\n    }\n\n    let creater = idCreater();\n    for (let i = 1; i <= 7; i++) {\n        console.log(\"[iterator]  [test-\" + 2 + \"]  [creater.next()] = \", creater.next());\n    }\n    console.log('');\n})();\n\n/**\n * ES6 中，有些数据结构原生具备 Iterator 接口\n * 就可以被 for...of 循环遍历\n *\n * 原因在于，这些数据结构原生部署了 Symbol.iterator 属性\n * 另外一些数据结构没有。凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口\n */"]}