{"version":3,"sources":["string-3.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;;;;;AASA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,wCAA3B,GAAsE,OAAO,YAAP,CAAoB,OAApB,CAAlF;;AAEA;;;;AAIA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yCAA3B,GAAuE,OAAO,aAAP,CAAqB,OAArB,CAAnF;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,4EAA3B,IAA2G,OAAO,aAAP,CAAqB,IAArB,EAA2B,OAA3B,EAAoC,IAApC,MAA8C,gBAAzJ,CAAZ;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAGA;;;;AAIA;;;AAGA,IAAI,OAAO,MAAX;;;;;;AACA,uBAAoB,IAApB,8HAA0B;AAAA,QAAjB,OAAiB;;AACtB,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,mBAA3B,GAAiD,OAA7D;AACH;;;;;;;;;;;;;;;;AACD,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;AAGA,IAAI,OAAO,OAAO,aAAP,CAAqB,OAArB,CAAX;AACA,KAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AAClC,UAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,iCAA3B,GAA+D,KAAK,CAAL,CAA3E;AACH;AACD,QAAQ,GAAR,CAAY,EAAZ;;;;;;AACA,wBAAoB,IAApB,mIAA0B;AAAA,QAAjB,QAAiB;;AACtB,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,4BAA3B,GAA0D,QAAtE;AACH;;AAED;;;;AAIA;;;;;;;;;;;;;;;;;;AAGA,QAAQ,qBAAR;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0BAA3B,GAAuD,KAAK,MAAL,CAAY,CAAZ,CAAnE;AACA;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,sBAA3B,GAAmD,KAAK,EAAL,CAAQ,CAAR,CAA/D","file":"string-3-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/************************\n * String.fromCodePoint *\n ************************/\n\n/**\n * ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字\n * 符（ Unicode 编号大于 0xFFFF ）\n *\n * 如: 0x20BB7\n *\n * 最高位 2 被舍弃了，最后返回码点 U+0BB7 对应的字符，而不是码点U+20BB7对应的字符\n */\n\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[String.fromCharCode(0x20BB7)] = \" + String.fromCharCode(0x20BB7));\n\n/**\n * ES6 提供了 String.fromCodePoint 方法，可以识别 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足\n * 如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回\n */\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[String.fromCodePoint(0x20BB7)] = \" + String.fromCodePoint(0x20BB7));\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\\\uD83D\\\\uDE80y'] = \" + (String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'));\nconsole.log(\"\");\n\n\n/*********************\n * 字符串的遍历器接口 *\n *********************/\n\n/**\n * ES6 为字符串添加了遍历器接口，使得字符串可以被 for...of 循环遍历\n */\nlet SAVE = \"Save\";\nfor (let element of SAVE) {\n    console.log(\"[string]\\t\\t[test-\" + 2 + \"]\\t\\t[element] = \" + element);\n}\nconsole.log(\"\");\n\n/**\n * 遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点\n */\nvar text = String.fromCodePoint(0x20BB7);\nfor (let i = 0; i < text.length; i++) {\n    console.log(\"[string]\\t\\t[test-\" + 3 + \"]\\t\\t[fromCodePoint#element] = \" + text[i]);\n}\nconsole.log(\"\");\nfor (let element of text) {\n    console.log(\"[string]\\t\\t[test-\" + 4 + \"]\\t\\t[for...of#element] = \" + element);\n}\n\n/********\n * at() *\n ********/\n\n/**\n * ES5 对字符串对象提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符\n */\nrequire('string.prototype.at');\nconsole.log(\"[string]\\t\\t[test-\" + 4 + \"]\\t\\t['𠮷'.charAt(0)] = \" +'𠮷'.charAt(0));\n// https://github.com/es-shims/String.prototype.at\nconsole.log(\"[string]\\t\\t[test-\" + 4 + \"]\\t\\t['𠮷'.at(0)] = \" +'𠮷'.at(0));\n"]}