{"version":3,"sources":["regexp-1.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;AAIA,IAAI,KAAK,IAAI,MAAJ,CAAW,MAAX,EAAmB,GAAnB,CAAT;AACA,IAAI,KAAK,OAAT;AACA,IAAI,KAAK,IAAI,MAAJ,CAAW,OAAX,CAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,mCAA3B,GAAiE,EAA7E;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,mBAA3B,GAAiD,EAA7D;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,+BAA3B,GAA6D,EAAzE;;AAEA;;;AAGA;;AAEA;;;;AAIA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,2CAA3B,GAAyE,IAAI,MAAJ,CAAW,QAAX,EAAqB,GAArB,EAA0B,KAA/G;;AAEA;;;;AAIA","file":"regexp-1-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/******************\n * RegExp构造函数 *\n ******************/\n\n/**\n * 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）\n */\n\nvar r1 = new RegExp('save', 'i');\nvar r2 = /save/i;\nvar r3 = new RegExp(/save/i);\nconsole.log(\"[regexp]\\t\\t[test-\" + 1 + \"]\\t\\t[new RegExp('save', 'i')] = \" + r1);\nconsole.log(\"[regexp]\\t\\t[test-\" + 1 + \"]\\t\\t[/save/i] = \" + r2);\nconsole.log(\"[regexp]\\t\\t[test-\" + 1 + \"]\\t\\t[new RegExp(/save/i)] = \" + r3);\n\n/**\n * 但是，ES5 不允许此时使用第二个参数，添加修饰符，否则会报错。\n */\n// var regex = new RegExp(/save/, 'i'); // ES5 上报错\n\n/**\n * ES6 改变了这种行为。如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而\n * 且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符\n */\nconsole.log(\"[regexp]\\t\\t[test-\" + 1 + \"]\\t\\t[new RegExp(/save/ig, 'i').flags] = \" + new RegExp(/save/ig, 'i').flags);\n\n/*******************\n * 字符串的正则方法 *\n *******************/\n\n/**\n * 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()  ()\n *\n * ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义\n * 在 RegExp 对象上\n *\n * String.prototype.match 调用 RegExp.prototype[Symbol.match]\n * String.prototype.replace 调用 RegExp.prototype[Symbol.replace]\n * String.prototype.search 调用 RegExp.prototype[Symbol.search]\n * String.prototype.split 调用 RegExp.prototype[Symbol.split]\n */\n\n\n\n"]}