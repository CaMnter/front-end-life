{"version":3,"sources":["numeric-5.js"],"names":[],"mappings":"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","file":"numeric-5-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/****************\n * Math.clz32() *\n ****************/\n\n/**\n * JavaScript 的整数使用 32 位二进制形式表示，Math.clz32 方法返回一个数的 32 位无符号整数形式有多少个前\n * 导 0\n *\n * 1 的二进制形式是 0b1，只占1位，所以 32 位之中有 31 个前导 0\n * 1000 的二进制形式是 0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0\n *\n * clz32 这个函数名就来自 \"count leading zero bits in 32-bit binary representations of a number\"\n *（计算 32 位整数的前导 0）的缩写\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 1 + \"]\\t\\t[Math.clz32(0)] = \" + Math.clz32(0));\nconsole.log(\"[numeric]\\t\\t[test-\" + 1 + \"]\\t\\t[Math.clz32(1)] = \" + Math.clz32(1));\nconsole.log(\"[numeric]\\t\\t[test-\" + 1 + \"]\\t\\t[Math.clz32(1000)] = \" + Math.clz32(1000));\nconsole.log(\"[numeric]\\t\\t[test-\" + 1 + \"]\\t\\t[Math.clz32(0b01000000000000000000000000000000)] = \" + Math.clz32(0b01000000000000000000000000000000));\nconsole.log(\"[numeric]\\t\\t[test-\" + 1 + \"]\\t\\t[Math.clz32(0b00100000000000000000000000000000)] = \" + Math.clz32(0b00100000000000000000000000000000));\nconsole.log(\"\");\n\n/**\n * 左移运算符（<<）与 Math.clz32 方法直接相关\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(0)] = \" + Math.clz32(0));\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(1)] = \" + Math.clz32(1));\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(1 << 1)] = \" + Math.clz32(1 << 1));\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(1 << 2)] = \" + Math.clz32(1 << 2));\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(1 << 3)] = \" + Math.clz32(1 << 3));\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(1 << 6)] = \" + Math.clz32(1 << 6));\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(1 << 29)] = \" + Math.clz32(1 << 29));\nconsole.log(\"\");\n\n/**\n * 对于小数，Math.clz32 方法只考虑整数部分\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(1.67)] = \" + Math.clz32(1.67));\nconsole.log(\"[numeric]\\t\\t[test-\" + 2 + \"]\\t\\t[Math.clz32(2.67)] = \" + Math.clz32(2.67));\nconsole.log(\"\");\n\n/**\n * 对于空值或其他类型的值，Math.clz32 方法会将它们先转为数值，然后再计算\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32()] = \" + Math.clz32());\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32(NaN)] = \" + Math.clz32(NaN));\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32(Infinity)] = \" + Math.clz32(Infinity));\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32(null)] = \" + Math.clz32(null));\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32('Save')] = \" + Math.clz32('Save'));\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32([])] = \" + Math.clz32([]));\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32({})] = \" + Math.clz32({}));\nconsole.log(\"[numeric]\\t\\t[test-\" + 3 + \"]\\t\\t[Math.clz32(true)] = \" + Math.clz32(true));\nconsole.log(\"\");\n\n/***************\n * Math.imul() *\n ***************/\n\n/**\n * Math.imul 方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 4 + \"]\\t\\t[Math.imul(2, 67)] = \" + Math.imul(2, 67));\nconsole.log(\"[numeric]\\t\\t[test-\" + 4 + \"]\\t\\t[Math.imul(-2, 67)] = \" + Math.imul(-2, 67));\nconsole.log(\"[numeric]\\t\\t[test-\" + 4 + \"]\\t\\t[Math.imul(-2, -67)] = \" + Math.imul(-2, -67));\nconsole.log(\"\");\n\n/**\n * 如果只考虑最后 32 位，大多数情况下，Math.imul(a, b) 与 a * b 的结果是相同的，即该方法等同于 (a * b)|0\n * 的效果（超过32位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的\n * 值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul 方法可以返回正确的\n * 低位数值\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 5 + \"]\\t\\t[(0x7fffffff * 0x7fffffff)|0] = \" + ((0x7fffffff * 0x7fffffff) | 0));\n/**\n * 这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二\n * 进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无\n * 法保存额外的精度，就把低位的值都变成了 0。Math.imul 方法可以返回正确的值 1\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 5 + \"]\\t\\t[Math.imul(0x7fffffff, 0x7fffffff)] = \" + Math.imul(0x7fffffff, 0x7fffffff));\nconsole.log(\"\");\n\n/*****************\n * Math.fround() *\n *****************/\n\n/**\n * Math.fround 方法返回一个数的单精度浮点数形式\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 6 + \"]\\t\\t[Math.fround(0)] = \" + Math.fround(0));\nconsole.log(\"[numeric]\\t\\t[test-\" + 6 + \"]\\t\\t[Math.fround(1)] = \" + Math.fround(1));\nconsole.log(\"[numeric]\\t\\t[test-\" + 6 + \"]\\t\\t[Math.fround(1.67)] = \" + Math.fround(1.67));\nconsole.log(\"[numeric]\\t\\t[test-\" + 6 + \"]\\t\\t[Math.fround(6.7)] = \" + Math.fround(6.7));\nconsole.log(\"[numeric]\\t\\t[test-\" + 6 + \"]\\t\\t[Math.fround(1.5)] = \" + Math.fround(1.5));\nconsole.log(\"[numeric]\\t\\t[test-\" + 6 + \"]\\t\\t[Math.fround(NaN)] = \" + Math.fround(NaN));\nconsole.log(\"\");\n\n/**\n * 对于整数来说，Math.fround 方法返回结果不会有任何不同，区别主要是那些无法用 64 个二进制位精确表示的小数。\n * 这时，Math.fround 方法会返回最接近这个小数的单精度浮点数\n *\n * ES5 部署 Math.fround\n */\nMath.fround = Math.fround || function (x) {\n        return new Float32Array([x])[0];\n    };\n\n/****************\n * Math.hypot() *\n ****************/\n\n/**\n * Math.hypot 方法返回所有参数的平方和的平方根\n *\n * 如果参数不是数值，Math.hypot 方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN\n */\nconsole.log(\"[numeric]\\t\\t[test-\" + 7 + \"]\\t\\t[Math.hypot(3, 4)] = \" + Math.hypot(3, 4));\nconsole.log(\"[numeric]\\t\\t[test-\" + 7 + \"]\\t\\t[Math.hypot(3, 4, 5)] = \" + Math.hypot(3, 4, 5));\nconsole.log(\"[numeric]\\t\\t[test-\" + 7 + \"]\\t\\t[Math.hypot(3, 4, 'Save')] = \" + Math.hypot(3, 4, 'Save'));\nconsole.log(\"[numeric]\\t\\t[test-\" + 7 + \"]\\t\\t[Math.hypot(3, '4')] = \" + Math.hypot(3, '4'));\nconsole.log(\"[numeric]\\t\\t[test-\" + 7 + \"]\\t\\t[Math.hypot(-3, -'4')] = \" + Math.hypot(-3, -'4'));\n\n\n\n\n\n"]}