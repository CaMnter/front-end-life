{"version":3,"sources":["function-13.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;;;AAOA;;;;;AAKA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,MAAI,MAAM,CAAV,EAAY,OAAO,CAAP;AACZ,SAAO,IAAI,GAAG,IAAI,CAAP,CAAX;AACH;AACD,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,iBAA7B,GAAiD,GAAG,CAAH,CAA7D;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;AAGA,SAAS,EAAT,CAAY,CAAZ,EAAe,KAAf,EAAsB;AAClB,MAAI,MAAM,CAAV,EAAY,OAAO,KAAP;AACZ,SAAO,GAAG,IAAI,CAAP,EAAU,IAAI,KAAd,CAAP;AACH;AACD,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,oBAA7B,GAAoD,GAAG,CAAH,EAAM,CAAN,CAAhE;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAGA;;;AAGA,SAAS,UAAT,CAAoB,CAApB,EAAuB;AACnB,MAAI,KAAK,CAAT,EAAW,OAAO,CAAP;AACX,SAAO,WAAW,IAAI,CAAf,IAAoB,WAAW,IAAI,CAAf,CAA3B;AACH;AACD,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,0BAA7B,GAA0D,WAAW,EAAX,CAAtE;;AAEA;AACA;AACA;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAGA;;;AAGA,SAAS,UAAT,CAAoB,CAApB,EAA4C;AAAA,MAArB,IAAqB,uEAAd,CAAc;AAAA,MAAX,KAAW,uEAAH,CAAG;;AACxC,MAAI,KAAK,CAAT,EAAY;AACR,WAAO,KAAP;AACH;;AAED,SAAO,WAAW,IAAI,CAAf,EAAkB,KAAlB,EAAyB,OAAO,KAAhC,CAAP;AACH;AACD,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,2BAA7B,GAA2D,WAAW,GAAX,CAAvE;AACA,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,4BAA7B,GAA4D,WAAW,IAAX,CAAxE;AACA,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,4BAA7B,GAA4D,WAAW,IAAX,CAAxE","file":"function-13-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/**********\n * 尾递归 *\n **********/\n\n/**\n * 如果尾调用自身，就称为 尾递归\n *\n * 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生 “栈溢出” 错误（stack overflow）。但对于\n * 尾递归来说，由于只存在一个调用帧，所以永远不会发生 “栈溢出” 错误\n */\n\n/**\n * 最多需要保存 n 个调用记录，复杂度 O(n)\n *\n * 不属于 尾递归, 因为不是直接 return 方法, 而且 return z*方法\n */\nfunction f1(z) {\n    if (z === 1)return 1;\n    return z * f1(z - 1);\n}\nconsole.log(\"[function]\\t\\t[test-\" + 1 + \"]\\t\\t[f1(5)] = \" + f1(5));\nconsole.log(\"\");\n\n/**\n * 尾递归  复杂度 O(1)\n */\nfunction f2(z, total) {\n    if (z === 1)return total;\n    return f2(z - 1, z * total);\n}\nconsole.log(\"[function]\\t\\t[test-\" + 2 + \"]\\t\\t[f2(5, 1)] = \" + f2(5, 1));\nconsole.log(\"\");\n\n\n/**\n * 非尾递归 Fibonacci\n */\nfunction fibonacciA(z) {\n    if (z <= 1)return 1;\n    return fibonacciA(z - 1) + fibonacciA(z - 2);\n}\nconsole.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[fibonacciA(10)] = \" + fibonacciA(10));\n\n// 溢出\n// console.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[fibonacciA(100)] = \" + fibonacciA(100));\n// console.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[fibonacciA(777)] = \" + fibonacciA(777));\nconsole.log(\"\");\n\n\n/**\n * @return {number}\n */\nfunction FibonacciB(z, last = 1, total = 1) {\n    if (z <= 1) {\n        return total;\n    }\n\n    return FibonacciB(z - 1, total, last + total);\n}\nconsole.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[FibonacciB(100)] = \" + FibonacciB(100));\nconsole.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[FibonacciB(1000)] = \" + FibonacciB(1000));\nconsole.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[FibonacciB(1000)] = \" + FibonacciB(1000));"]}