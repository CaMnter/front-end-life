{"version":3,"sources":["function-10.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;;;;;;;AAUA;;;;;;;;;;AAUA,IAAI,OAAO,MAAX;AACA,SAAS,EAAT,GAAc;AAAA;;AACV,eAAW,YAAK;AACZ,gBAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,gBAA7B,GAAgD,MAAK,IAAjE;AACH,KAFD,EAEG,GAFH;AAGH;AACD,GAAG,IAAH,CAAQ,EAAC,MAAM,wBAAP,EAAR;;AAGA;;;;;;AAMA,SAAS,KAAT,GAAiB;AAAA;;AACb,SAAK,EAAL,GAAU,CAAV;AACA,SAAK,EAAL,GAAU,CAAV;AACA;AACA,gBAAY;AAAA,eAAI,OAAK,EAAL,EAAJ;AAAA,KAAZ,EAA2B,IAA3B;AACA;AACA,gBAAY,YAAY;AACpB,aAAK,EAAL;AACH,KAFD,EAEG,IAFH;AAGH;AACD,IAAI,QAAQ,IAAI,KAAJ,EAAZ;AACA,WAAW,YAAK;AACZ,YAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,oBAA7B,GAAoD,MAAM,EAAtE;AACH,CAFD,EAEG,IAFH;AAGA,WAAW,YAAK;AACZ,YAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,oBAA7B,GAAoD,MAAM,EAAtE;AACH,CAFD,EAEG,IAFH;;AAKA;;;;;;;;;AASA,IAAI,UAAU;AACV,QAAI,QADM;AAEV,UAAM,gBAAY;AAAA;;AACd,iBAAS,gBAAT,CAA0B,OAA1B,EACI;AAAA,mBAAS,OAAK,WAAL,CAAiB,MAAM,IAAvB,CAAT;AAAA,SADJ,EAC2C,KAD3C;AAEH,KALS;AAMV,iBAAa,qBAAU,IAAV,EAAgB;AACzB,gBAAQ,GAAR,CAAY,cAAc,IAAd,GAAqB,OAArB,GAA+B,KAAK,EAAhD;AACH;AARS,CAAd;;AAWA;;;;;;AAMA;;;AAGA,SAAS,WAAT,GAAuB;AAAA;;AACnB,eAAW,YAAK;AACZ,gBAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,gBAA7B,GAAgD,OAAK,IAAjE;AACH,KAFD,EAEG,GAFH;AAGH;AACD;AACA,SAAS,WAAT,GAAuB;AACnB,QAAI,SAAS,IAAb;;AAEA,eAAW,YAAY;AACnB,gBAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,gBAA7B,GAAgD,OAAO,IAAnE;AACH,KAFD,EAEG,GAFH;AAGH;;AAED;;;;AAIA,SAAS,EAAT,GAAc;AAAA;;AACV,eAAW,YAAM;AACb,gBAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,qBAAzC;AACA,gBAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,sBAAzC,EAAiE,IAAI,MAArE;AACH,KAHD,EAGG,GAHH;AAIH;AACD,GAAG,CAAH,EAAM,CAAN,EAAS,CAAT;;AAEA;;;;;;AAMA,CAAC,YAAY;AAAA;;AACT,WAAO,CACF;AAAA,eAAM,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,kBAAzC,EAA6D,OAAK,CAAlE,CAAN;AAAA,KAAD,CAA6E,IAA7E,CAAkF,EAAC,GAAG,OAAJ,EAAlF,GADG,CAAP;AAGH,CAJD,EAIG,IAJH,CAIQ,EAAC,GAAG,OAAJ,EAJR;;AAOA;;;AAGA;AACA,SAAS,GAAT,GAAe;AAAA;;AACX;AACA,WAAO,YAAM;AACT;AACA,eAAO,YAAM;AACT;AACA,mBAAO,YAAM;AACT;AACA,wBAAQ,GAAR,CAAY,OAAZ,EAAqB,OAAK,IAA1B;AACH,aAHD;AAIH,SAND;AAOH,KATD;AAUH","file":"function-10-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/************************\n * 箭头函数 - 使用注意点 *\n ************************/\n\n/**\n * JavaScript 语言的 this 对象一直是一个令人头痛的问题，在对象方法中使用 this，必须非常小心。箭头函数 ”绑定” this，很\n * 大程度上解决了这个困扰\n */\n\n/**\n *（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。\n *\n *（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。\n *\n *（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。\n *\n *（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数\n */\n\n/**\n *\n * 如果是普通函数，执行时 this 应该指向全局对象 window\n * 输出 Save\n *\n * 但是，箭头函数导致 this 总是指向函数定义生效时所在的对象{sign: 'Save you from anything'}\n * 所以输出的是 Save you from anything\n *\n * @type {string}\n */\nvar sign = 'Save';\nfunction f1() {\n    setTimeout(()=> {\n        console.log(\"[function]\\t\\t[test-\" + 1 + \"]\\t\\t[sign] = \" + this.sign);\n    }, 267);\n}\nf1.call({sign: 'Save you from anything'});\n\n\n/**\n * 箭头函数 的 this 绑定了 定义时所在的作用域 Timer 对象.\n * 普通函数 的 this 指向运行时所在的作用域 全局作用域\n *\n * @constructor Timer\n */\nfunction Timer() {\n    this.v1 = 0;\n    this.v2 = 0;\n    // 箭头函数\n    setInterval(()=>this.v1++, 1000);\n    // 普通函数\n    setInterval(function () {\n        this.v2++;\n    }, 1000)\n}\nvar timer = new Timer();\nsetTimeout(()=> {\n    console.log(\"[function]\\t\\t[test-\" + 2 + \"]\\t\\t[timer.v1] = \" + timer.v1);\n}, 2666);\nsetTimeout(()=> {\n    console.log(\"[function]\\t\\t[test-\" + 2 + \"]\\t\\t[timer.v2] = \" + timer.v2);\n}, 2666);\n\n\n/**\n * 箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数。\n * 下面是一个例子，DOM 事件的回调函数封装在一个对象里面\n *\n * 代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this，总是指向 handler 对象。\n * 否则，回调函数运行时，this.doSomething 这一行会报错，因为此时 this 指向 document 对象\n *\n * @type {{id: string, init: handler.init, doSomething: handler.doSomething}}\n */\nvar handler = {\n    id: '123456',\n    init: function () {\n        document.addEventListener('click',\n            event => this.doSomething(event.type), false);\n    },\n    doSomething: function (type) {\n        console.log('Handling ' + type + ' for ' + this.id);\n    }\n};\n\n/**\n * 箭头函数原理:\n * this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部\n * 的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数\n */\n\n/**\n * ES5 ES6 对比\n */\nfunction es6function() {\n    setTimeout(()=> {\n        console.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[sign] = \" + this.sign);\n    }, 100);\n}\n// babel 转换后\nfunction es6function() {\n    var _this5 = this;\n\n    setTimeout(function () {\n        console.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[sign] = \" + _this5.sign);\n    }, 100);\n}\n\n/**\n * 除了 this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target\n */\n\nfunction f2() {\n    setTimeout(() => {\n        console.log(\"[function]\\t\\t[test-\" + 4 + \"]\\t\\t[arguments] = \", arguments);\n        console.log(\"[function]\\t\\t[test-\" + 4 + \"]\\t\\t[new.target] = \", new.target);\n    }, 100);\n}\nf2(2, 6, 7);\n\n/**\n * 由于箭头函数没有自己的 this，所以当然也就不能用 call()、apply()、bind() 这些方法去改变 this 的指向\n *\n * 箭头函数没有自己的 this，所以 bind 方法无效，内部的 this 指向外部的 this\n *\n */\n(function () {\n    return [\n        (() => console.log(\"[function]\\t\\t[test-\" + 5 + \"]\\t\\t[this.x] = \", this.x)).bind({x: 'inner'})()\n    ];\n}).call({x: 'outer'});\n\n\n/**\n * 下面只有一个 this\n */\n// 指向 全局对象 window this\nfunction foo() {\n    // 函数作用域 this\n    return () => {\n        // 没有 this => 指向 函数作用域 foo this\n        return () => {\n            // 没有 this => 指向 函数作用域 foo this\n            return () => {\n                // 没有 this => 指向 函数作用域 foo this\n                console.log('name:', this.name);\n            };\n        };\n    };\n}\n\n"]}