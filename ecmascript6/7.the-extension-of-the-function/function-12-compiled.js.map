{"version":3,"sources":["function-12.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;;;AAOA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,WAAO,IAAI,CAAX;AACH;;AAED,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,WAAO,IAAI,CAAX;AACH;;AAED;AACA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,WAAO,GAAG,CAAH,CAAP;AACH;;AAED;AACA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,QAAI,QAAQ,GAAG,CAAH,CAAZ;AACA,WAAO,KAAP;AACH;;AAED;AACA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,WAAO,GAAG,CAAH,IAAQ,CAAf;AACH;;AAED;AACA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,OAAG,CAAH;AACH;;AAED;;;;;AAKA;AACA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,OAAG,CAAH;AACA,WAAO,SAAP;AACH;;AAED;;;;;AAKA,SAAS,EAAT,CAAY,CAAZ,EAAe;AACX,QAAI,IAAI,CAAR,EAAW;AACP,eAAO,GAAG,CAAH,CAAP;AACH;AACD,WAAO,GAAG,CAAH,CAAP;AACH;;AAGD;;;;AAIA;;;;;;;;;;;;AAYA,SAAS,CAAT,GAAa;AACT,QAAI,IAAI,CAAR;AACA,QAAI,IAAI,CAAR;AACA,WAAO,EAAE,IAAI,CAAN,CAAP;AACH;AACD;;AAEA;AACA,SAAS,CAAT,GAAa;AACT;AACH;AACD;;AAEA;AACA;;AAEA;;;;;;;;AAQA;;;AAGA,SAAS,MAAT,CAAgB,CAAhB,EAAkB;AACd,QAAI,MAAM,CAAV;AACA,aAAS,KAAT,CAAe,CAAf,EAAiB;AACb,eAAO,IAAI,GAAX;AACH;AACD,WAAO,MAAM,CAAN,CAAP;AACH;AACD","file":"function-12-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/**********\n * 尾调用 *\n **********/\n\n/**\n * 尾调用（Tail Call）是函数式编程的一个重要概念，\n * 本身非常简单，一句话就能说清楚，就是指\n *\n * 某个函数的最后一步是调用另一个函数\n */\n\nfunction f0(z) {\n    return 1 / z;\n}\n\nfunction f1(z) {\n    return z * z;\n}\n\n// 属于 尾调用\nfunction f2(z) {\n    return f1(z);\n}\n\n// 不属于 尾调用\nfunction f3(z) {\n    let tempZ = f1(z);\n    return tempZ;\n}\n\n// 不属于 尾调用\nfunction f4(z) {\n    return f1(z) + z;\n}\n\n// 不属于 尾调用\nfunction f4(z) {\n    f1(z);\n}\n\n/**\n * f4 等同于 f5\n *\n * 所以不属于\n */\n// 不属于 尾调用\nfunction f5(z) {\n    f1(z);\n    return undefined;\n}\n\n/**\n * 尾调用不一定出现在函数尾部，只要是最后一步操作即可\n *\n * f0 和 f1 都属于尾调用, 因为都是最后一步操作\n */\nfunction f6(z) {\n    if (z > 0) {\n        return f1(z);\n    }\n    return f0(z);\n}\n\n\n/**************\n * 尾调用优化 *\n **************/\n\n/**\n * 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n *\n * 函数调用会在内存形成一个 “调用记录”，又称 “调用帧”（call frame），保存调用位置\n * 和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。等到 B\n * 运行结束，将结果返回到 A，B 的调用帧才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用帧，以\n * 此类推。所有的调用帧，就形成一个 “调用栈”（call stack）。\n *\n * 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到\n * 了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了\n */\n\nfunction f() {\n    let m = 1;\n    let n = 2;\n    return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n    // return g(3);\n}\nf();\n\n// 等同于\n// g(3);\n\n/**\n * 上面代码中，如果函数 g 不是尾调用，函数f就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。但由于调用 g\n * 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧\n *\n * 这就叫做 “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么\n * 完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是 “尾调用优化” 的意义\n */\n\n/**\n * 注: 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行 “尾调用优化”\n */\nfunction addOne(a){\n    var one = 1;\n    function inner(b){\n        return b + one;\n    }\n    return inner(a);\n}\n/**\n * 上面的函数不会进行尾调用优化，因为内层函数 inner 用到了外层函数 addOne 的内部变量 one\n */\n\n\n\n"]}