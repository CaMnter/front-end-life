{"version":3,"sources":["function-14.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;AAKA,SAAS,EAAT,CAAY,CAAZ,EAAe,CAAf,EAAkB;AACd,QAAI,IAAI,CAAR,EAAW;AACP,eAAO,GAAG,IAAI,CAAP,EAAU,IAAI,CAAd,CAAP;AACH,KAFD,MAEO;AACH,eAAO,CAAP;AACH;AACJ;AACD;AACA;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;;;;;AAOA,SAAS,UAAT,CAAoB,CAApB,EAAuB;AACnB,WAAO,KAAK,aAAa,QAAzB,EAAmC;AAC/B,YAAI,GAAJ;AACH;AACD,WAAO,CAAP;AACH;AACD;;;AAGA,SAAS,GAAT,CAAa,CAAb,EAAgB,CAAhB,EAAmB;AACf,QAAI,IAAI,CAAR,EAAW;AACP,eAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,IAAI,CAAnB,EAAsB,IAAI,CAA1B,CAAP;AACH,KAFD,MAEO;AACH,eAAO,CAAP;AACH;AACJ;AACD,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,sCAA7B,GAAsE,WAAW,IAAI,CAAJ,EAAO,MAAP,CAAX,CAAlF;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAGA;;;;AAIA,SAAS,GAAT,CAAa,CAAb,EAAgB;AACZ,QAAI,KAAJ;AACA,QAAI,SAAS,KAAb;AACA,QAAI,cAAc,EAAlB;;AAEA,WAAO,SAAS,WAAT,GAAuB;AAC1B;AACA,oBAAY,IAAZ,CAAiB,SAAjB;AACA,YAAI,CAAC,MAAL,EAAa;AACT,qBAAS,IAAT;AACA,mBAAO,YAAY,MAAnB,EAA2B;AACvB,wBAAQ,EAAE,KAAF,CAAQ,IAAR,EAAc,YAAY,KAAZ,EAAd,CAAR;AACH;AACD,qBAAS,KAAT;AACA,mBAAO,KAAP;AACH;AACJ,KAXD;AAYH;;AAED,IAAI,SAAS,IAAI,UAAU,CAAV,EAAa,CAAb,EAAgB;AAC7B,QAAI,IAAI,CAAR,EAAW;AACP,eAAO,IAAI,IAAI,CAAR,EAAW,IAAI,CAAf,CAAP;AACH,KAFD,MAGK;AACD,eAAO,CAAP;AACH;AACJ,CAPY,CAAb;AAQA,QAAQ,GAAR,CAAY,yBAAyB,CAAzB,GAA6B,yCAA7B,GAAyE,WAAW,OAAO,CAAP,EAAU,MAAV,CAAX,CAArF","file":"function-14-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/*******************\n * 尾递归优化的实现 *\n *******************/\n\n/**\n * 尾递归优化只在严格模式下生效，那么正常模式下\n *\n * 就是自己实现尾递归优化\n */\nfunction f1(x, y) {\n    if (y > 0) {\n        return f1(x + 1, y - 1);\n    } else {\n        return x;\n    }\n}\n// Maximum call stack size exceeded\n// console.log(\"[function]\\t\\t[test-\" + 1 + \"]\\t\\t[f1(1,233333)] = \" + f1(1, 233333));\nconsole.log(\"\");\n\n/**\n * 蹦床函数 （trampoline）可以将递归执行转为循环执行\n *\n * 接受一个函数 f 作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该\n * 函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题\n */\n\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n/**\n * 改写为每一步返回 另一个函数\n */\nfunction sum(x, y) {\n    if (y > 0) {\n        return sum.bind(null, x + 1, y - 1);\n    } else {\n        return x;\n    }\n}\nconsole.log(\"[function]\\t\\t[test-\" + 2 + \"]\\t\\t[trampoline(sum(1, 233333))] = \" + trampoline(sum(1, 233333)));\nconsole.log(\"\");\n\n\n/*******************\n * 真正的尾递归优化 *\n *******************/\n\nfunction tco(f) {\n    var value;\n    var active = false;\n    var accumulated = [];\n\n    return function accumulator() {\n        // 保存 function\n        accumulated.push(arguments);\n        if (!active) {\n            active = true;\n            while (accumulated.length) {\n                value = f.apply(this, accumulated.shift());\n            }\n            active = false;\n            return value;\n        }\n    }\n}\n\nvar sumTco = tco(function (x, y) {\n    if (y > 0) {\n        return sum(x + 1, y - 1)\n    }\n    else {\n        return x\n    }\n});\nconsole.log(\"[function]\\t\\t[test-\" + 3 + \"]\\t\\t[trampoline(sumTco(1, 233333))] = \" + trampoline(sumTco(1, 233333)));\n"]}