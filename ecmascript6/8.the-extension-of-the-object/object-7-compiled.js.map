{"version":3,"sources":["object-7.js"],"names":[],"mappings":";;;;;;AAAA;;;;AAIA;;;;AAIA;;;;AAIA,IAAI,KAAK,EAAC,MAAM,wBAAP,EAAiC,SAAS,SAA1C,EAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,uDAAvC,EAAgG,IAAhG,EAAsG,OAAO,wBAAP,CAAgC,EAAhC,EAAoC,MAApC,CAAtG,EAAmJ,IAAnJ;;AAEA;;;;;;;;;;;;;AAaA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,oFAAvC,EAA6H,OAAO,wBAAP,CAAgC,OAAO,SAAvC,EAAkD,UAAlD,EAA8D,UAA3L,EAAuM,IAAvM;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,oEAAvC,EAA6G,OAAO,wBAAP,CAAgC,EAAhC,EAAoC,QAApC,EAA8C,UAA3J,EAAuK,IAAvK;;AAEA;;;;;;AAMA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yFAAvC,EAAkI,OAAO,wBAAP,CAAgC;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,0BAAa,CAAE;AAAf;;AAAA;AAAA,IAAiB,SAAjD,EAA4D,KAA5D,EAAmE,UAArM,EAAiN,IAAjN","file":"object-7-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/*****************\n * 属性的可枚举性 *\n *****************/\n\n/**\n * 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。\n * Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象\n */\nlet o1 = {save: \"Save you from anything\", camnter: \"CaMnter\"};\nconsole.log(\"[object]\\t\\t[test-\" + 1 + \"]\\t\\t[Object.getOwnPropertyDescriptor(o1, 'save')] = \", '\\n', Object.getOwnPropertyDescriptor(o1, 'save'), '\\n');\n\n/**\n * 描述对象的 enumerable 属性，称为 ”可枚举性“，如果该属性为 false，就表示某些操作会忽略当前属性。\n *\n * ES5 有三个操作会忽略 enumerable 为 false 的属性\n * - for...in 循环：只遍历对象自身的和继承的可枚举的属性\n * - Object.keys()：返回对象自身的所有可枚举的属性的键名\n * - JSON.stringify()：只串行化对象自身的可枚举的属性\n *\n * ES6 新增了一个操作 Object.assign()，会忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性\n *\n * 这四个操作之中，只有 for...in 会返回继承的属性。实际上，引入 enumerable 的最初目的，就是让某些属性可以规避掉 for...in 操作。\n * 比如，对象原型的 toString 方法，以及数组的 length 属性，就通过这种手段，不会被 for...in 遍历到\n */\nconsole.log(\"[object]\\t\\t[test-\" + 2 + \"]\\t\\t[Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable] = \", Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable, '\\n');\nconsole.log(\"[object]\\t\\t[test-\" + 2 + \"]\\t\\t[Object.getOwnPropertyDescriptor([], 'length').enumerable] = \", Object.getOwnPropertyDescriptor([], 'length').enumerable, '\\n');\n\n/**\n * ES6 规定，所有 Class 的原型的方法都是不可枚举的\n * 操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，\n *\n * 注意: 尽量不要用 for...in 循环，而用 Object.keys() 代替\n */\nconsole.log(\"[object]\\t\\t[test-\" + 3 + \"]\\t\\t[Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable] = \", Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable, '\\n');"]}