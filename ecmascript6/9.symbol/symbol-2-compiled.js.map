{"version":3,"sources":["symbol-2.js"],"names":[],"mappings":";;;;AAAA;;;;AAIA;;;;AAIA;;;;;;;AAOA,IAAI,KAAK,QAAT;;AAEA;AACA,IAAI,KAAK,EAAT;AACA,GAAG,EAAH,IAAS,QAAT;;AAEA;AACA,IAAI,yBACC,EADD,EACM,QADN,CAAJ;;AAIA;AACA,IAAI,KAAK,EAAT;AACA,OAAO,cAAP,CAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAAC,OAAO,QAAR,EAA9B;;AAEA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,kBAAvC,EAA2D,GAAG,EAAH,CAA3D;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,kBAAvC,EAA2D,GAAG,EAAH,CAA3D;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,kBAAvC,EAA2D,GAAG,EAAH,CAA3D,EAAmE,IAAnE;;AAEA;;;;;;;;;AASA;;;AAGA,IAAI,yBACC,EADD,YACK,KADL,EACW;AACP,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,iBAAvC,EAA0D,KAA1D,EAAiE,IAAjE;AACH,CAHD,CAAJ;AAKA,GAAG,EAAH,EAAO,aAAP;;AAEA;;;AAGA,IAAM,MAAM,EAAZ;AACA,IAAI,MAAJ,GAAa;AACT,WAAO,OAAO,OAAP,CADE;AAET,UAAM,OAAO,MAAP,CAFG;AAGT,UAAM,OAAO,MAAP;AAHG,CAAb;AAKA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,4BAAvC,EAAqE,IAAI,MAAJ,CAAW,KAAhF;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,2BAAvC,EAAoE,IAAI,MAAJ,CAAW,IAA/E;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,2BAAvC,EAAoE,IAAI,MAAJ,CAAW,IAA/E,EAAqF,IAArF;;AAGA;;;;;;AAMA,IAAM,QAAQ,QAAd;AACA,IAAM,QAAQ,QAAd;;AAEA,SAAS,WAAT,CAAqB,KAArB,EAA4B;AACxB,YAAQ,KAAR;AACI,aAAK,KAAL;AACI,mBAAO,KAAP;AACJ,aAAK,KAAL;AACI,mBAAO,KAAP;AACJ;AACI,kBAAM,IAAI,KAAJ,CAAU,iBAAV,CAAN;AANR;AAQH","file":"symbol-2-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/*********************\n * Symbol 作为属性名 *\n ********************/\n\n/**\n * Symbol 的值是唯一的\n * 用于对象上的话, 可以保证不会出现同名属性\n *\n * 如果这个对象由多个模块构成的话, 可以防止被不小心修改\n */\n\nlet s1 = Symbol();\n\n// 第一种写法\nlet o1 = {};\no1[s1] = 'Save-1';\n\n// 第二种写法\nlet o2 = {\n    [s1]: 'Save-2'\n}\n\n// 第三种写法\nlet o3 = {};\nObject.defineProperty(o3, s1, {value: 'Save-3'});\n\nconsole.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[o1[s1]] = \", o1[s1]);\nconsole.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[o2[s1]] = \", o2[s1]);\nconsole.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[o3[s1]] = \", o3[s1], '\\n');\n\n/**\n * 注意:\n * Symbol值作为对象属性名时, 不能用点运算符\n * 因为 . 后面都是字符\n *\n * 用第二种方法定义的时候必须将 Symbol 放在方括号内\n * 不然该属性的 key 就变为 字符\n */\n\n/**\n * 采用增强的对象写法\n */\nlet o4 = {\n    [s1](value){\n        console.log(\"[symbol]\\t\\t[test-\" + 2 + \"]\\t\\t[value] = \", value, '\\n');\n    }\n};\no4[s1]('o4-s1-value');\n\n/**\n * 定义常量\n */\nconst log = {};\nlog.levels = {\n    DEBUG: Symbol('debug'),\n    INFO: Symbol('info'),\n    WARN: Symbol('warn')\n};\nconsole.log(\"[symbol]\\t\\t[test-\" + 3 + \"]\\t\\t[log.levels.DEBUG] = \", log.levels.DEBUG);\nconsole.log(\"[symbol]\\t\\t[test-\" + 3 + \"]\\t\\t[log.levels.INFO] = \", log.levels.INFO);\nconsole.log(\"[symbol]\\t\\t[test-\" + 3 + \"]\\t\\t[log.levels.WARN] = \", log.levels.WARN, '\\n');\n\n\n/**\n * 常量使用 Symbol 值最大的好处\n * 就是其他任何值都不可能有相同的值了\n * 因此可以保证上面的 switch 语句会按设计的方式工作\n */\n\nconst BLACK = Symbol();\nconst WHITE = Symbol();\n\nfunction switchColor(color) {\n    switch (color) {\n        case BLACK:\n            return BLACK;\n        case WHITE:\n            return WHITE;\n        default:\n            throw new Error('Undefined color');\n    }\n}"]}