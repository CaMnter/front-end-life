{"version":3,"sources":["string-2.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;AAIA;AACA;AACA,IAAI,KAAK,IAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,qBAA3B,GAAmD,GAAG,MAAlE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,wBAA3B,GAAsD,GAAG,MAAH,CAAU,CAAV,CAAlE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,wBAA3B,GAAsD,GAAG,MAAH,CAAU,CAAV,CAAlE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,4BAA3B,GAA0D,GAAG,UAAH,CAAc,CAAd,CAAtE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,4BAA3B,GAA0D,GAAG,UAAH,CAAc,CAAd,CAAtE;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;;;;AAMA,IAAI,KAAK,KAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,6BAA3B,GAA2D,GAAG,WAAH,CAAe,CAAf,CAAvE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,6BAA3B,GAA2D,GAAG,WAAH,CAAe,CAAf,CAAvE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,6BAA3B,GAA2D,GAAG,WAAH,CAAe,CAAf,CAAvE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0CAA3B,GAAwE,GAAG,WAAH,CAAe,CAAf,EAAkB,QAAlB,CAA2B,EAA3B,CAApF;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0CAA3B,GAAwE,GAAG,WAAH,CAAe,CAAf,EAAkB,QAAlB,CAA2B,EAA3B,CAApF;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;;;;;;;;AAKA,uBAAe,EAAf,8HAAmB;AAAA,QAAV,EAAU;;AACf,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0CAA3B,GAAwE,GAAG,WAAH,CAAe,CAAf,EAAkB,QAAlB,CAA2B,EAA3B,CAApF;AACH;;;;;;;;;;;;;;;;AACD,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;AAGA,SAAS,OAAT,CAAiB,IAAjB,EAAuB;AACnB,SAAO,KAAK,WAAL,CAAiB,CAAjB,IAAsB,MAA7B;AACH;AACD,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,2BAA3B,GAAyD,QAAQ,IAAR,CAArE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0BAA3B,GAAwD,QAAQ,GAAR,CAApE","file":"string-2-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/*****************\n * codePointAt() *\n *****************/\n\n/**\n * JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的\n * 字符（ Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符\n */\n// 汉字 “𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271\n// 需要 4 个字节储存\nvar s1 = \"𠮷\";\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[s1.length] = \" + s1.length);\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[s1.charAt(0)] = \" + s1.charAt(0));\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[s1.charAt(1)] = \" + s1.charAt(1));\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[s1.charCodeAt(0)] = \" + s1.charCodeAt(0));\nconsole.log(\"[string]\\t\\t[test-\" + 1 + \"]\\t\\t[s1.charCodeAt(1)] = \" + s1.charCodeAt(1));\nconsole.log(\"\");\n\n/**\n * JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分\n * 别返回前两个字节和后两个字节的值\n *\n * ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点\n */\nvar s2 = \"𠮷a\";\nconsole.log(\"[string]\\t\\t[test-\" + 2 + \"]\\t\\t[s2.codePointAt(0)] = \" + s2.codePointAt(0));\nconsole.log(\"[string]\\t\\t[test-\" + 2 + \"]\\t\\t[s2.codePointAt(1)] = \" + s2.codePointAt(1));\nconsole.log(\"[string]\\t\\t[test-\" + 2 + \"]\\t\\t[s2.codePointAt(2)] = \" + s2.codePointAt(2));\nconsole.log(\"[string]\\t\\t[test-\" + 2 + \"]\\t\\t[s2.codePointAt(0).toString(16)] = \" + s2.codePointAt(0).toString(16));\nconsole.log(\"[string]\\t\\t[test-\" + 2 + \"]\\t\\t[s2.codePointAt(2).toString(16)] = \" + s2.codePointAt(2).toString(16));\nconsole.log(\"\");\n\n/**\n * codePointAt 方法的参数，仍然是不正确的。比如，上面代码中，字符 a 在字符串 s2 的正确位置序号应该是 1，但\n * 是必须向 codePointAt 方法传入 2。解决这个问题的一个办法是使用 for...of 循环，因为它会正确识别 32 位的\n * UTF-16 字符\n */\nfor (let ch of s2) {\n    console.log(\"[string]\\t\\t[test-\" + 3 + \"]\\t\\t[ch.codePointAt(0).toString(16)] = \" + ch.codePointAt(0).toString(16));\n}\nconsole.log(\"\");\n\n/**\n * codePointAt 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法\n */\nfunction is32Bit(char) {\n    return char.codePointAt(0) > 0xFFFF;\n}\nconsole.log(\"[string]\\t\\t[test-\" + 4 + \"]\\t\\t[is32Bit(\\\"𠮷\\\")] = \" + is32Bit(\"𠮷\"));\nconsole.log(\"[string]\\t\\t[test-\" + 4 + \"]\\t\\t[is32Bit(\\\"a\\\")] = \" + is32Bit(\"a\"));\n\n"]}