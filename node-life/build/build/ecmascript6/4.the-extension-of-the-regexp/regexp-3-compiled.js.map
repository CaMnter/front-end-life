{"version":3,"sources":["regexp-3.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;;;;;;;;;;AAYA,IAAI,IAAI,WAAR;AACA,IAAI,KAAK,KAAT;AACA;AACA,GAAG,IAAH,CAAQ,CAAR,E,CAAW;AACX;;AAEA,GAAG,IAAH,CAAQ,CAAR,E,CAAW;AACX;;AAEA;;;;;;AAMA,IAAI,KAAK,SAAT;AACA;;AAEA;AACA;;AAEA;;;;AAIA,IAAM,QAAQ,IAAd;AACA;AACA,MAAM,SAAN,GAAkB,CAAlB;AACA;AACA,IAAM,QAAQ,MAAM,IAAN,CAAW,MAAX,CAAd;AACA;AACA,MAAM,KAAN,C,CAAY;AACZ,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,uBAA3B,GAAqD,MAAM,KAAvE;AACA;AACA,MAAM,SAAN,C,CAAgB;AAChB,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,2BAA3B,GAAyD,MAAM,SAA3E;AACA;AACA,MAAM,IAAN,CAAW,MAAX,E,CAAmB;;AAEnB,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;;;AAIA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,QAAT,CAAkB,WAAlB,EAA+B,GAA/B,EAAoC;AAChC,MAAI,SAAS,EAAb;AACA,MAAI,cAAJ;AACA,SAAO,QAAQ,YAAY,IAAZ,CAAiB,GAAjB,CAAf,EAAsC;AAClC,WAAO,IAAP,CAAY,MAAM,CAAN,CAAZ;AACH;AACD,SAAO,MAAP;AACH;;AAED;;;;;;;AAOA,SAAS,OAAT,EAAkB,QAAlB;AACA;AACA,SAAS,OAAT,EAAkB,QAAlB;AACA","file":"regexp-3-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/************\n * y 修饰符 *\n ************/\n\n/**\n * ES6 还为正则表达式添加了 y 修饰符，叫做 “粘连”（sticky）修饰符\n *\n * y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在\n * 于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是 “粘连” 的\n * 涵义\n *\n * 一个使用 g 修饰符，另一个使用 y 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩\n * 余字符串都是 _ss_s。由于 g 修饰没有位置要求，所以第二次执行会返回结果，而 y 修饰符要求匹配必须从头部开始\n * 所以返回 null\n */\n\nvar s = \"sss_ss_ss\";\nvar r1 = /s+/g;\n// var r2 = /s+/y;\nr1.exec(s) // [\"sss\"]\n// r2.exec(s) // [\"ss\"]\n\nr1.exec(s) // [\"ss\"]\n// r2.exec(s) // null\n\n/**\n * 改一下正则表达式，保证每次都能头部匹配，y 修饰符就会返回结果了\n *\n * lastIndex 属性指定每次搜索的开始位置，g 修饰符从这个位置开始向后搜索，直到发现匹配为止\n */\n\nvar s2 = 'sss_ss_';\n// var r = /s+_/y;\n\n// r.exec(s2) // [\"sss_\"]\n// r.exec(s2) // [\"ss_\"]\n\n/**\n * 使用 lastIndex 属性，可以更好地说明 y 修饰符\n */\n\nconst REGEX = /x/g;\n// 指定从 2 号位置（y）开始匹配\nREGEX.lastIndex = 2;\n// 匹配成功\nconst match = REGEX.exec('exex');\n// 在3号位置匹配成功\nmatch.index // 3\nconsole.log(\"[regexp]\\t\\t[test-\" + 1 + \"]\\t\\t[match.index] = \" + match.index);\n// 下一次匹配从 4 号位开始\nREGEX.lastIndex // 4\nconsole.log(\"[regexp]\\t\\t[test-\" + 1 + \"]\\t\\t[REGEX.lastIndex] = \" + REGEX.lastIndex);\n// 4 号位开始匹配失败\nREGEX.exec('exex') // null\n\nconsole.log(\"\");\n\n/**\n * y 修饰符同样遵守 lastIndex 属性，但是要求必须在 lastIndex 指定的位置发现匹配\n */\n// const REGEX2 = /x/y;\n// 指定从 2 号位置开始匹配\n// REGEX2.lastIndex = 2;\n// // 不是粘连，匹配失败\n// REGEX2.exec('exex'); // null\n// // 指定从 3 号位置开始匹配\n// REGEX2.lastIndex = 3;\n// // 3 号位置是粘连，匹配成功\n// const match2 = REGEX2.exec('exex');\n// match2.index // 3\n// REGEX2.lastIndex // 4\n// console.log(\"[regexp]\\t\\t[test-\" + 2 + \"]\\t\\t[match2.index] = \" + match2.index);\n// console.log(\"[regexp]\\t\\t[test-\" + 2 + \"]\\t\\t[REGEX2.lastIndex] = \" + REGEX2.lastIndex);\n// console.log(\"\");\n\n/**\n * y 修饰符号隐含了头部匹配的标志 ^\n */\n// /x/y.exec('exe');\n\n/**\n * 在 split 方法中使用 y 修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是\n * 空字符串\n */\n\n// 没有找到匹配\n// 'x##'.split(/#/y);\n// [ 'x##' ]\n\n// 找到两个匹配\n// '##x'.split(/#/y);\n// [ '', '', 'x' ]\n\n/**\n * 后续的分隔符只有紧跟前面的分隔符，才会被识别\n */\n\n// '#x#'.split(/#/y);\n// // [ '', 'x#' ]\n//\n// '##'.split(/#/y);\n// // [ '', '', '' ]\n\n/**\n * 字符串对象的 replace 方法的例子\n */\n\n// const REGEX3 = /a/gy;\n// 最后一个 a 因为不是出现下一次匹配的头部，所以不会被替换\n// 'aaxa'.replace(REGEX, '-') // '--xa'\n\n/**\n * 单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配\n */\n\n// 'a1a2a3'.match(/a\\d/y); // [\"a1\"]\n// 'a1a2a3'.match(/a\\d/gy); // [\"a1\", \"a2\", \"a3\"]\n\n/**\n * y 修饰符的一个应用，是从字符串提取 token（词元），y 修饰符确保了匹配之间不会有漏掉的字符\n */\n\n// const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y;\n// const TOKEN_G  = /\\s*(\\+|[0-9]+)\\s*/g;\n//\n// tokenize(TOKEN_Y, '3 + 4')\n// // [ '3', '+', '4' ]\n// tokenize(TOKEN_G, '3 + 4')\n// // [ '3', '+', '4' ]\n\nfunction tokenize(TOKEN_REGEX, str) {\n    let result = [];\n    let match;\n    while (match = TOKEN_REGEX.exec(str)) {\n        result.push(match[1]);\n    }\n    return result;\n}\n\n/**\n * 上面代码中，如果字符串里面没有非法字符，y 修饰符与 g 修饰符的提取结果是一样的。但是，一旦出现非法字符，两\n * 者的行为就不一样了\n *\n * g 修饰符会忽略非法字符，而 y 修饰符不会，这样就很容易发现错误\n */\n\ntokenize(TOKEN_Y, '3x + 4')\n// [ '3' ]\ntokenize(TOKEN_G, '3x + 4')\n// [ '3', '+', '4' ]\n\n\n\n\n\n\n"]}