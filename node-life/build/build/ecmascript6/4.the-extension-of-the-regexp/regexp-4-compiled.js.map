{"version":3,"sources":["regexp-4.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;AAIA;;;AAGA;AACA;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;;AAIA;;;;AAIA;AACA;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0BAA3B,GAAwD,QAAQ,MAA5E;AACA;;AAEA;AACA;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yBAA3B,GAAuD,QAAQ,KAA3E;AACA;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;;AAIA;;;;AAIA,SAAS,YAAT,CAAsB,GAAtB,EAA2B;AACvB,SAAO,IAAI,OAAJ,CAAY,qCAAZ,EAAmD,MAAnD,CAAP;AACH;AACD,IAAI,KAAK,qCAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,4BAA3B,GAA0D,aAAa,EAAb,CAAtE;;AAEA,IAAM,SAAS,QAAQ,eAAR,CAAf;AACA,OAAO,IAAP;AACA,IAAI,KAAK,8BAAT;AACA;AACA,IAAI,WAAW,OAAO,EAAP,CAAf;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,oBAA3B,GAAkD,QAA9D;;AAEA,IAAI,MAAM,qBAAV;AACA,IAAI,QAAQ,IAAI,MAAJ,CAAW,OAAO,GAAP,CAAX,EAAwB,GAAxB,CAAZ;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yBAA3B,GAAuD,OAAO,KAAP,CAAnE;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;;AAIA;;;;AAIA;;;;;;;;AAQA;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,uCAA3B,GAAqE,UAAU,IAAV,CAAe,UAAf,CAAjF;AACA;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yCAA3B,GAAuE,YAAY,IAAZ,CAAiB,UAAjB,CAAnF;;AAEA;;;AAGA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA,QAAQ,GAAR,CAAY,EAAZ;;AAEA;;;;;AAKA;;;;AAIA;;;;;;;;AAQA;;;;;;;;;AASA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0DAA3B,GAAwF,WAAW,IAAX,CAAgB,6BAAhB,CAApG;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,gFAA3B,GAA8G,WAAW,IAAX,CAAgB,mDAAhB,CAA1H;;AAEA;;;;;;;AAOA;AACA","file":"regexp-4-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/***************\n * sticky 属性 *\n ***************/\n\n/**\n * 与 y 修饰符相匹配，ES6 的正则对象多了 sticky 属性，表示是否设置了 y 修饰符\n */\n// var r = /hellow\\d/y;\n// console.log(\"[regexp]\\t\\t[test-\" + 1 + \"]\\t\\t[r.sticky] = \" + r.sticky);\nconsole.log(\"\");\n\n/**************\n * flags 属性 *\n **************/\n\n/**\n * ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符\n */\n\n// ES5 的 source属性\n// 返回正则表达式的正文\nconsole.log(\"[regexp]\\t\\t[test-\" + 2 + \"]\\t\\t[/abc/ig.source] = \" + /abc/ig.source);\n// \"abc\"cd\n\n// ES6的flags属性\n// 返回正则表达式的修饰符\nconsole.log(\"[regexp]\\t\\t[test-\" + 2 + \"]\\t\\t[/abc/ig.flags] = \" + /abc/ig.flags);\n// 'gi'\nconsole.log(\"\");\n\n/*******************\n * RegExp.escape() *\n *******************/\n\n/**\n * 字符串必须转义，才能作为正则模式\n */\n\nfunction escapeRegExp(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nlet s2 = '/path/to/resource.html?search=query';\nconsole.log(\"[regexp]\\t\\t[test-\" + 3 + \"]\\t\\t[escapeRegExp(s2)] = \" + escapeRegExp(s2));\n\nconst ESCAPE = require('regexp.escape');\nESCAPE.shim();\nlet s3 = \"Save . you . from . anything\";\n//noinspection JSUnresolvedFunction\nlet escapeS3 = ESCAPE(s3);\nconsole.log(\"[regexp]\\t\\t[test-\" + 3 + \"]\\t\\t[escapeS3] = \" + escapeS3);\n\nvar str = 'hello. how are you?';\nvar regex = new RegExp(ESCAPE(str), 'g');\nconsole.log(\"[regexp]\\t\\t[test-\" + 3 + \"]\\t\\t[String(regex)] = \" + String(regex));\nconsole.log(\"\");\n\n/*************************\n * s 修饰符：dotAll 模式 *\n *************************/\n\n/**\n * 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外\n */\n\n/**\n * 以下四个字符属于 ”行终止符“\n *      U+000A 换行符（\\n）\n *      U+000D 回车符（\\r）\n *      U+2028 行分隔符（line separator）\n *      U+2029 段分隔符（paragraph separator）\n */\n\n// . 不匹配 \\n，所以正则表达式返回 false\nconsole.log(\"[regexp]\\t\\t[test-\" + 4 + \"]\\t\\t[/foo.bar/.test('foo\\\\nbar')] = \" + /foo.bar/.test('foo\\nbar'));\n// 有一种变通的写法\nconsole.log(\"[regexp]\\t\\t[test-\" + 4 + \"]\\t\\t[/foo[^]bar/.test('foo\\\\nbar')] = \" + /foo[^]bar/.test('foo\\nbar'));\n\n/**\n * 引入 /s 修饰符，使得.可以匹配任意单个字符\n */\n// console.log(\"[regexp]\\t\\t[test-\" + 4 + \"]\\t\\t[/foo.bar/s.test('foo\\\\nbar')] = \" + /foo.bar/s.test('foo\\nbar'));\n\n/**\n * 这被称为 dotAll 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔\n * 值，表示该正则表达式是否处在 dotAll 模式\n */\n// const re = /foo.bar/s;\n// console.log(\"[regexp]\\t\\t[test-\" + 4 + \"]\\t\\t[re.test('foo\\nbar')] = \" + re.test('foo\\nbar'));\n// console.log(\"[regexp]\\t\\t[test-\" + 4 + \"]\\t\\t[re.dotAll] = \" + re.dotAll);\n// console.log(\"[regexp]\\t\\t[test-\" + 4 + \"]\\t\\t[re.flags] = \" + re.flags);\nconsole.log(\"\");\n\n/**\n * /s 修饰符和多行修饰符 /m 不冲突，两者一起使用的情况下，.匹配所有字符，而 ^ 和 $ 匹配\n * 每一行的行首和行尾\n */\n\n/************\n * 后行断言 *\n ************/\n\n/**\n * JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后\n * 行断言（lookbehind）和后行否定断言（negative lookbehind）\n *\n * ES7 加入后行断言。V8 引擎 4.9版 已经支持，Chrome 浏览器 49版 打开 ”experimental JavaScript features“\n * 开关（地址栏键入 about:flags ），就可以使用这项功能\n */\n\n/**\n * ”先行断言“ 指的是，x 只有在 y 前面才匹配，必须写成 /x(?=y)/。比如，只匹配百分号之前的数字，要写成\n * /\\d+(?=%)/\n *\n * ”先行否定断言“ 指的是，x 只有不在 y 前面才匹配，必须写成 /x(?!y)/。比如，只匹配不在百分号之前的数字，要\n * 写成 /\\d+(?!%)/\n *\n * ”先行断言“括号之中的部分（(?=%)），是不计入返回结果的\n */\nconsole.log(\"[regexp]\\t\\t[test-\" + 5 + \"]\\t\\t[/\\d+(?=%)/.exec('267% Save you from anything')] = \" + /\\d+(?=%)/.exec('267% Save you from anything'));\nconsole.log(\"[regexp]\\t\\t[test-\" + 5 + \"]\\t\\t[/\\d+(?!%)/.exec('Save you from anything 267 Save you from anything')] = \" + /\\d+(?!%)/.exec('Save you from anything 267 Save you from anything'));\n\n/**\n * \"后行断言\" 正好与 \"先行断言\" 相反，x 只有在 y 后面才匹配，必须写成 /(?<=y)x/。比如，只匹配美元符号之后\n * 的数字，要写成 /(?<=\\$)\\d+/\n *\n * ”后行否定断言“ 则与 ”先行否定断言“ 相反，x 只有不在 y 后面才匹配，必须写成 /(?<!y)x/。比如，只匹配不在\n * 美元符号后面的数字，要写成 /(?<!\\$)\\d+/\n */\n// console.log(\"[regexp]\\t\\t[test-\" + 5 + \"]\\t\\t[/(?<=\\$)\\d+/.exec('Save you from anything $267')] = \" + /(?<=\\$)\\d+/.exec('Save you from anything $267'));\n// console.log(\"[regexp]\\t\\t[test-\" + 5 + \"]\\t\\t[/(?<=\\$)\\d+/.exec('Save you from anything €267')] = \" + /(?<!\\$)\\d+/.exec('Save you from anything €267'));\n\n\n\n\n\n\n\n\n"]}