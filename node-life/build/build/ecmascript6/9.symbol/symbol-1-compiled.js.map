{"version":3,"sources":["symbol-1.js"],"names":[],"mappings":";;;;AAAA;;;;AAIA;;;;AAIA;;;;;;;;;;;;;;;;AAgBA,IAAI,KAAK,QAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,qBAAvC,SAAqE,EAArE,yCAAqE,EAArE,GAAyE,IAAzE;;AAEA;;;;;AAKA;;;AAGA,IAAI,KAAK,OAAO,MAAP,CAAT;AACA,IAAI,KAAK,OAAO,wBAAP,CAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,cAAvC,EAAuD,EAAvD;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,cAAvC,EAAuD,EAAvD,EAA2D,IAA3D;;AAGA;;;;;AAKA,IAAI,KAAK;AACL,UADK,sBACK;AACN,WAAO,aAAP;AACH;AAHI,CAAT;AAKA,IAAI,KAAK,OAAO,EAAP,CAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,cAAvC,EAAuD,EAAvD,EAA2D,IAA3D;;AAEA;;;AAGA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,iCAAvC,EAA0E,aAAa,QAAvF;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,6CAAvC,EAAsF,OAAO,MAAP,MAAmB,OAAO,MAAP,CAAzG,EAAyH,IAAzH;;AAEA,IAAI,KAAK,OAAO,UAAP,CAAT;AACA;AACA;;AAEA;;;;;AAKA,IAAI,KAAK,OAAO,SAAP,CAAT;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,sBAAvC,EAA+D,OAAO,EAAP,CAA/D;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,yBAAvC,EAAkE,GAAG,QAAH,EAAlE;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,gBAAvC,EAAyD,CAAC,CAAC,EAA3D;AACA,QAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,uBAAvC,EAAgE,QAAQ,EAAR,CAAhE","file":"symbol-1-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/**********\n * Symbol *\n **********/\n\n/**\n * ES5 中, 对象的属性都是 String\n * 如果你想添加一个新属性, 名字还一样了, 这样就造成属性冲突.\n *\n * Symbol 保证每个属性的名字都是独一无二\n * 从根本上防止属性名的冲突.\n * 这就是ES6引入Symbol的原因\n *\n * ES6 引入了一种新的原始数据类型 Symbol\n * JavaScript 语言的第七种数据类型\n * 前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\n *\n * ES6 以后, 对象的属性名现在可以有两种类型. 一种是 String, 一种是 Symbol\n * 凡是属性名属于Symbol类型, 就都是独一无二的, 可以保证不会与其他属性名产生冲突\n */\n\nlet s1 = Symbol();\nconsole.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[typeof s1] = \", typeof s1, '\\n');\n\n/**\n * 注意, Symbol 函数前不能使用 new 命令, 否则会报错\n * 这是因为生成的 Symbol 是一个原始类型的值, 不是对象\n */\n\n/**\n * String 作为参数\n */\nlet s2 = Symbol('Save');\nlet s3 = Symbol('Save you from anything');\nconsole.log(\"[symbol]\\t\\t[test-\" + 2 + \"]\\t\\t[s2] = \", s2);\nconsole.log(\"[symbol]\\t\\t[test-\" + 2 + \"]\\t\\t[s3] = \", s3, '\\n');\n\n\n/**\n * 对象 作为参数\n *\n * 会先调用 toString 方法 拿到 String, 然后再实例化 Symbol\n */\nlet o1 = {\n    toString(){\n        return 'o1-toString';\n    }\n};\nlet s4 = Symbol(o1);\nconsole.log(\"[symbol]\\t\\t[test-\" + 3 + \"]\\t\\t[s4] = \", s4, '\\n');\n\n/**\n * 唯一性\n */\nconsole.log(\"[symbol]\\t\\t[test-\" + 4 + \"]\\t\\t[Symbol() === Symbol()] = \", Symbol() === Symbol());\nconsole.log(\"[symbol]\\t\\t[test-\" + 4 + \"]\\t\\t[Symbol('Save') === Symbol('Save')] = \", Symbol('Save') === Symbol('Save'), '\\n');\n\nlet s5 = Symbol('anything');\n// \"Save you from \" + s5;\n// `Save you from ${s5}`;\n\n/**\n * Symbol 值可以显式转为字符串\n * Symbol 值也可以转为布尔值\n *        但是不能转为数值\n */\nlet s6 = Symbol('CaMnter');\nconsole.log(\"[symbol]\\t\\t[test-\" + 5 + \"]\\t\\t[String(s6)] = \", String(s6));\nconsole.log(\"[symbol]\\t\\t[test-\" + 5 + \"]\\t\\t[s6.toString()] = \", s6.toString());\nconsole.log(\"[symbol]\\t\\t[test-\" + 5 + \"]\\t\\t[!!s6] = \", !!s6);\nconsole.log(\"[symbol]\\t\\t[test-\" + 5 + \"]\\t\\t[Boolean(s6)] = \", Boolean(s6));"]}