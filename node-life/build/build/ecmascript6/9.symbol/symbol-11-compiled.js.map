{"version":3,"sources":["symbol-11.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;AAIA;;;;AAIA;;;;;;;IAOM,a;AAEF,2BAAY,KAAZ,EAAmB;AAAA;;AACf,aAAK,KAAL,GAAa,KAAb;AACH;;;aAEA,OAAO,K;8BAAO,M,EAAQ;AACnB,oBAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,oDAAvC;AACA,gBAAI,QAAQ,OAAO,OAAP,CAAe,KAAK,KAApB,CAAZ;AACA,gBAAI,UAAU,CAAC,CAAf,EAAiB,OAAO,MAAP;AACjB,mBAAO,CACH,OAAO,MAAP,CAAc,CAAd,EAAiB,KAAjB,CADG,EAEH,OAAO,MAAP,CAAc,QAAQ,KAAK,KAAL,CAAW,MAAjC,CAFG,CAAP;AAIH;;;;;;AAIL,CAAC,YAAM;AACH,QAAI,OAAO,wBAAX;AACA,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,sDAAvC,EAA+F,KAAK,KAAL,CAAW,IAAI,aAAJ,CAAkB,MAAlB,CAAX,CAA/F,EAAsI,IAAtI;AACA,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,qDAAvC,EAA8F,KAAK,KAAL,CAAW,IAAI,aAAJ,CAAkB,KAAlB,CAAX,CAA9F,EAAoI,IAApI;AACA,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,mDAAvC,EAA4F,KAAK,KAAL,CAAW,IAAI,aAAJ,CAAkB,GAAlB,CAAX,CAA5F,EAAgI,IAAhI;AACA,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,qDAAvC,EAA8F,KAAK,KAAL,CAAW,IAAI,aAAJ,CAAkB,KAAlB,CAAX,CAA9F,EAAoI,IAApI;AACH,CAND;;AASA;;;;AAIA;;;;AAIA,CAAC,YAAM;AACH,QAAI,iBAAiB,EAArB;AACA,mBAAe,OAAO,QAAtB,4BAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BACxB,CADwB;;AAAA;AAAA;AAAA,+BAExB,CAFwB;;AAAA;AAAA;AAAA,+BAGxB,CAHwB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAlC;AAKA,YAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,6BAAvC,+BAA0E,cAA1E,IAA2F,IAA3F;;AAEA;;;;AATG;AAAA;AAAA;;AAAA;AAaH,6BAAoB,cAApB,8HAAoC;AAAA,gBAA3B,OAA2B;;AAChC,oBAAQ,GAAR,CAAY,uBAAuB,CAAvB,GAA2B,0BAAvC,EAAmE,CAAC,OAAD,CAAnE;AACH;AAfE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBN,CAhBD","file":"symbol-11-compiled.js","sourcesContent":["/**\n * Created by：CaMnter\n */\n\n/****************\n * Symbol.split *\n ****************/\n\n/**\n * 对象的 Symbol.split 属性\n * 指向一个方法\n *\n * 当该对象被  String.prototype.split方法调用时\n * 会返回该方法的返回值\n */\nclass SplitterClass {\n\n    constructor(value) {\n        this.value = value;\n    }\n\n    [Symbol.split](string) {\n        console.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[SplitterClass[Symbol.split](string)] >>>>>> \");\n        let index = string.indexOf(this.value);\n        if (index === -1)return string;\n        return [\n            string.substr(0, index),\n            string.substr(index + this.value.length)\n        ];\n    }\n\n}\n\n(() => {\n    let SAVE = 'Save you from anything';\n    console.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[SAVE.split(new SplitterClass('Save'))] >>>>>> \", SAVE.split(new SplitterClass('Save')), '\\n');\n    console.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[SAVE.split(new SplitterClass('you'))] >>>>>> \", SAVE.split(new SplitterClass('you')), '\\n');\n    console.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[SAVE.split(new SplitterClass('a'))] >>>>>> \", SAVE.split(new SplitterClass('a')), '\\n');\n    console.log(\"[symbol]\\t\\t[test-\" + 1 + \"]\\t\\t[SAVE.split(new SplitterClass('233'))] >>>>>> \", SAVE.split(new SplitterClass('233')), '\\n');\n})();\n\n\n/*******************\n * Symbol.iterator *\n *******************/\n\n/**\n * 对象的 Symbol.iterator 属性\n * 指向该对象的默认遍历器方法\n */\n(() => {\n    var iteratorTarget = {};\n    iteratorTarget[Symbol.iterator] = function*() {\n        yield 2;\n        yield 3;\n        yield 3;\n    }\n    console.log(\"[symbol]\\t\\t[test-\" + 2 + \"]\\t\\t[...iteratorTarget] = \", [...iteratorTarget], '\\n');\n\n    /**\n     * 对象进行 for...of 循环时\n     * 会调用 Symbol.iterator 方法\n     */\n    for (var element of iteratorTarget) {\n        console.log(\"[symbol]\\t\\t[test-\" + 3 + \"]\\t\\t[element] >>>>>> = \", [element]);\n    }\n})();"]}